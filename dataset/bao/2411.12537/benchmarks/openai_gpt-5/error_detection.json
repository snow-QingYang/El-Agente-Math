{
  "metadata": {
    "paper_id": "2411.12537",
    "model": "openai/gpt-5",
    "context_words": 300,
    "total_formulas_checked": 20,
    "timestamp": "2025-10-31T17:58:45.525578",
    "benchmark_mode": true
  },
  "detections": [
    {
      "label": "<<FORMULA_0378>>",
      "formula": "\\mA(1)^k = \\mP \\mJ^k \\mP^{-1}, \\quad \\mJ_{i}^k=\\left[\\begin{array}{cccccc}\n\\lambda_i^k & \\binom{k}{1} \\lambda_l^{k-1} & \\binom{k}{2} \\lambda_i^{k-2} & \\cdots & \\cdots & \\binom{k}{k_i-1} \\lambda_i^{k-k_i+1} \\\\\n& \\lambda_i^k & \\binom{k}{1} \\lambda_i^{k-1} & \\cdots & \\cdots & \\binom{k}{k_i-2} \\lambda_i^{k-k_i+2} \\\\\n& & \\ddots & \\ddots & \\vdots & \\vdots \\\\\n& & & \\ddots & \\ddots & \\vdots \\\\\n& & & & \\lambda_i^k & \\binom{k}{1} \\lambda_i^{k-1} \\\\\n& & & & & \\lambda_i^k\n\\end{array}\\right].",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "In the first row, second entry of the Jordan block, the eigenvalue is written as λ_l^{k-1} instead of λ_i^{k-1}; the subscript should be i consistently.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 10.44
    },
    {
      "label": "<<FORMULA_0004>>",
      "formula": "\\label{eq:linrnn}\n\\begin{gathered}\n    \\mH_i =  \\mA(\\vx_i) \\mH_{i-1} \\\\times \\mB(\\vx_i), \\quad \\hat{\\vy}_i = \\mathrm{dec}(\\mH_i, \\vx_i), \\quad \\text{ for all } i \\in \\{1, \\dots, t\\}, \\\\\n\\mH_0 \\in \\C^{n \\times d}, \\quad \\mA: \\R^l \\to \\C^{n \\times n}, \\quad  \\mB: \\R^l \\to \\C^{n \\times d}, \\quad \\mathrm{dec}: \\C^{n \\times d} \\times \\R^l \\to \\R^p\n\\end{gathered}",
      "has_error": true,
      "error_type": "operator_swap",
      "error_description": "The recurrence uses multiplication (\\times) instead of addition: A(x_i)H_{i-1} \\times B(x_i) is dimensionally invalid for n×d matrices; it should be A(x_i)H_{i-1} + B(x_i).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 16.23
    },
    {
      "label": "<<FORMULA_0215>>",
      "formula": "\\indic{s} := \\begin{cases}\n        1 \\text{ if  $s$ is true} \\\\\n        0 \\text{ if $s$ is false }\n    \\end{cases}, \\qquad \\mathrm{sign}(x) := \\begin{cases}\n        1 &\\text{if } x \\geq 0 \\\\\n        -1 &\\text{if } x > 0\n    \\end{cases}.",
      "has_error": true,
      "error_type": "inequality_flip",
      "error_description": "In the definition of sign(x), the second case incorrectly uses x > 0; it should be x < 0 to avoid conflict with the first case.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 16.8
    },
    {
      "label": "<<FORMULA_0428>>",
      "formula": "\\widehat\\mC_l := \\mathrm{cast}(\\mA(1)^k \\mB) = \\begin{cases}\n        \\overline\\mC_1 \\text{ if } k \\bmod 2 = 1 \\\\\n        \\overline\\mC_2 \\text{ if } k \\bmod 2 = 0\n    \\end{cases}\n    \\widehat\\mD_k := \\mathrm{cast}(\\mA(1)^k \\mH_0) =  \\begin{cases}\n        \\overline\\mD_1 \\text{ if } k \\bmod 2 = 1 \\\\\n        \\overline\\mD_2 \\text{ if } k \\bmod 2 = 0\n    \\end{cases}",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "Inconsistent index variable: the definition uses \\widehat\\mC_l but the RHS and case conditions use k (and A(1)^k); it should consistently use the same index (e.g., \\widehat\\mC_k or cases in terms of l).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 18.32
    },
    {
      "label": "<<FORMULA_0479>>",
      "formula": "\\mR(\\theta) := \\Big[\\begin{array}{cc}\n\\cos \\theta & -\\sin \\theta \\\\\n\\sin \\theta & \\cos \\theta\n\\end{array}\\Big] = \\left(\\mI + 2\\vv_1\\vv_1^\\top\\right)\\left(\\mI - 2\\vv_2\\vv_2^\\top\\right), \\quad \\theta = \\frac{2\\pi}{m}.",
      "has_error": true,
      "error_type": "sign_flip",
      "error_description": "The first reflection is written as I + 2 v1 v1^T, but a Householder reflection is I - 2 v v^T; it should be (I - 2 v1 v1^T)(I - 2 v2 v2^T).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 20.75
    },
    {
      "label": "<<FORMULA_0125>>",
      "formula": "\\label{eq:GHset}\n    \\mathcal{M}_{k}^n(\\Omega) : =\\left\\{\\mC_1\\mC_2 \\cdots \\mC_k \\ : \\ \\mC_i = \\mI - \\beta_i \\vv_i \\vv_i^\\top, \\quad (1- \\beta_i) \\in \\Omega, \\quad \\vv_i \\in \\R^{n},\\, \\lVert \\vv_i \\rVert = 1 \\right\\}.",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 24.21
    },
    {
      "label": "<<FORMULA_0457>>",
      "formula": "\\widehat\\mH_{2k}^{(2)} = \\begin{cases}\n        \\overline\\mH^{(2)}_1 \\text{ if } k \\bmod 2 = 0 \\\\\n        \\overline\\mH^{(2)}_2 \\text{ if } k \\bmod 2 = 1 \n    \\end{cases}, \\quad     \\widehat\\mH_{2k - 1}^{(2)} = \\begin{cases}\n        \\overline\\mH^{(2)}_3 \\text{ if } k \\bmod 2 = 0 \\\\\n        \\overline\\mH^{(2)}_4 \\text{ if } k \\bmod 2 = 1 \n    \\end{cases}.",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "The odd-index subsequence is written as \\widehat{\\mH}^{(2)}_{2k-1} instead of the context-consistent \\widehat{\\mH}^{(2)}_{2k+1} used elsewhere for odd indices.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 25.73
    },
    {
      "label": "<<FORMULA_0406>>",
      "formula": "\\label{eq:hoscillating}\n    \\widehat\\mH_{k} := \\begin{cases}\n        \\overline{\\mH}_1 \\quad \\text{if } k \\mod 2 = 0 \\\\\n        \\overline{\\mH}_2 \\quad \\text{otherwise} \n    \\end{cases}, \\quad \\hat y_k  = \\begin{cases}\n        \\bar y_1 \\quad \\text{if } k \\mod 2 = 0 \\\\\n        \\bar y_2 \\quad \\text{otherwise}\n    \\end{cases}",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 28.57
    },
    {
      "label": "<<FORMULA_0647>>",
      "formula": "\\mH^{(i)}_t &= \\mA^{(i)}(w^{(i)}_t) \\mH^{(i)}_{t-1} - \\mB^{(i)}(w^{(i)}_t), \\qquad  \\mH^{(i)}_0 = (1,0\\dots,0)^\\top \\in \\R^n \\\\  \n     y^{(i)} &= \\mathrm{dec}^{(i)}(\\mH_t^{(i)}, w_t^{(i)})   = (g(\\mH_t^{(i)}), w_t^{(i)}) = (\\delta^{(i)}(q_0^{(i)}, \\vw^{(i)}), w^{(i)})",
      "has_error": true,
      "error_type": "sign_flip",
      "error_description": "The state update uses H_t = A(w_t) H_{t-1} - B(w_t); it should add B(w_t). With A=0 for reset transitions, subtraction yields -e_{q(w)} instead of the intended one-hot e_{q(w)}.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 25.19
    },
    {
      "label": "<<FORMULA_0356>>",
      "formula": "a_{2k} &= \\sum_{i=1}^n \\hat{c}_i\\binom{2k}{m_i}  |\\lambda_i|^{2k- m_i}, \\quad \\hat{c}_i = c_i\\mathrm{sign}(\\lambda_i)^{2k- m_i} \\\\\na_{2k+1} &= \\sum_{i=1}^n \\tilde{c}_i\\binom{2k+1}{m_i}  |\\lambda_i|^{2k+1- m_i}, \\quad \\tilde{c}_i = c_i \\mathrm{sign}(\\lambda_i)^{2k+1- m_i},",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 43.02
    },
    {
      "label": "<<FORMULA_0652>>",
      "formula": "y^{(s)}_t &= \\mathrm{dec}^{(s)}(\\mH_t, w_t^{(s)}) \\\\\n&= (\\delta^{(s)}(q_0^{(s)}, \\vw^{(s)}),y_t^{(s-1)}) \\\\\n&= (\\delta^{(s)}(q_0^{(s)}, \\vw^{(s)}), \\delta^{(s-1)}(q_0^{(s-1)}, \\vw^{(s-1)}), y_t^{(s-2)}) \\\\   \n&= (\\delta^{(s)}(q_0^{(s)}, \\vw^{(s)}),\\dots, \\delta^{(1)}(q_0^{(1)}, \\vw), w_t) \\in \\N^{s+1},",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "In the first line, dec^{(s)} is applied to H_t without the layer superscript; it should be H_t^{(s)} to match the s-th layer notation.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 26.92
    },
    {
      "label": "<<FORMULA_0681>>",
      "formula": "\\vh^{(2)}_{0} = (1,0)^\\top, \\quad  \\vh^{(2)}_t = \\mA^{(2)}(\\vy^{(1)}_t) \\vh^{(2)}_{t + 1}, \\quad \\vy^{(2)}_t = \\mathrm{dec}^{(2)}(\\vh_t^{(2)}, \\vy^{(1)}_t)  \\\\\n    \\mA^{(2)}(\\vy) = \\mH(\\theta(y_1, y_2)) = \\left[\\begin{array}{cc}\n\\cos \\theta(y_1, y_2) &  \\sin \\theta(y_1, y_2) \\\\\n\\sin \\theta(y_1, y_2) & -\\cos \\theta(y_1, y_2)\n\\end{array}\\right] \\\\\n    \\mathrm{dec}^{(2)}(\\vh, \\vy) = \\argmax_{i \\in \\{0, \\dots, m-1\\}} \\max (\\vc_i^\\top \\vh, \\vd_i^\\top \\vh) \\quad",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "The state update uses the future state h^{(2)}_{t+1} on the right-hand side (h^{(2)}_t = A^{(2)}(y^{(1)}_t) h^{(2)}_{t+1}), which reverses the time index. It should use the previous/current state, e.g., h^{(2)}_{t+1} = A^{(2)}(y^{(1)}_t) h^{(2)}_{t} (or equivalently h^{(2)}_t = A^{(2)}(y^{(1)}_t) h^{(2)}_{t-1}).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 24.72
    },
    {
      "label": "<<FORMULA_0507>>",
      "formula": "\\mP = \\prod_{l=1}^{k-1} \\mP_{i_l j_l}, \\quad, \\mP_{ij} = (I - 2\\vv_{ij} \\vv_{ij}^\\top) \\qquad v_{ijl} = \\begin{cases}\n       1/\\sqrt{2} \\quad \\text{ if } l = i \\\\\n       -1/\\sqrt{2} \\quad \\text{ if } l = j \\\\\n       0 \\quad \\text{ otherwise} \n   \\end{cases},",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 40.83
    },
    {
      "label": "<<FORMULA_0643>>",
      "formula": "\\begin{aligned}\n    \\mA^{(i)}(w)_{q',q}  &= \\indic{\\delta(q, w)= q'}, && \\mB^{(i)}(w)_{q'} = 0,  \\quad  &&\\text{ if } \\delta^{(i)}(\\cdot, w) \\text{ is bijective, or} \\\\\n    \\mA^{(i)}(w)_{q',q}  &= 0, && \\mB^{(i)}(w)_{q'} = \\indic{q' = q(w)},  &&\\text{ if } \\delta^{(i)}(\\cdot, w) \\equiv q(w).\n\\end{aligned}",
      "has_error": true,
      "error_type": "sign_flip",
      "error_description": "In the reset case (δ^{(i)}(·, w) ≡ q(w)), setting A=0 and B=1_{q'=q(w)} combined with the update H_t = A H_{t-1} - B yields H_t = -e_{q(w)} instead of e_{q(w)}; the sign should be flipped (use +B or set B = -1_{q'=q(w)}).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 37.64
    },
    {
      "label": "<<FORMULA_0431>>",
      "formula": "\\widehat\\mH_{2k} &= \\mathrm{cast}\\left(\\sum_{i=1}^{\\tau-1} \\widehat \\mC_i  + \\left(k - \\frac{\\tau}{2} +1\\right) \\overline \\mC_2 + \\left(k - \\frac{\\tau}{2}\\right) \\overline \\mC_1 + k\\overline\\mD_2 \\right) \\\\\n    \\widehat\\mH_{2k+1} &= \\mathrm{cast}\\left(\\sum_{i=1}^{\\tau-1} \\widehat \\mC_i+ \\left(k - \\frac{\\tau}{2} +1\\right)  (\\overline\\mC_2 + \\overline \\mC_1) + k\\overline\\mD_1 \\right)  \\\\",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 62.25
    },
    {
      "label": "<<FORMULA_0694>>",
      "formula": "\\begin{aligned}\n\\mR(\\alpha) \\mR(\\gamma) & =\\mR(\\alpha + \\gamma), \\quad \n &&\\mH(\\alpha)\\mH(\\gamma)  =\\mR(\\alpha- \\gamma), \\\\\n\\mR(\\alpha) \\mH(\\gamma) & =\\mH\\left(\\alpha+ \\gamma\\right) \n&&\\mH(\\gamma) \\mR(\\alpha)  =\\mH\\\\geft(\\gamma-\\alpha\\right).\n\\end{aligned}",
      "has_error": true,
      "error_type": "missing_parentheses",
      "error_description": "In the last identity, the command is misspelled as \\geft instead of \\left, creating a mismatched \\left/\\right pair: \\mH(\\gamma)\\mR(\\alpha)=\\mH\\geft(\\gamma-\\alpha\\right).",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 47.99
    },
    {
      "label": "<<FORMULA_0695>>",
      "formula": "\\label{eq:dtoc}\n\\begin{aligned}\n     \\mH(\\theta(j,1))\\vd_i &= \\mH(\\theta(j,1))\\mR(2i\\pi/m)\\vd_0 \\\\\n     &= \\mH(\\theta(j,1))\\mR(2i\\pi/m)\\mH(\\pi/m)\\vc_0 \\\\\n     &= \\mH(\\theta(j,1))\\mH(\\theta(i,0))\\vc_0 \\\\\n     &= \\mR( \\theta(j,1) - \\theta(i,0))\\vc_0 \\\\\n     &= \\mR(-2(i+j)\\pi/m)\\vc_0 = \\vc_{i+j \\bmod m},\n\\end{aligned}",
      "has_error": false,
      "error_type": "none",
      "error_description": "",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 54.26
    },
    {
      "label": "<<FORMULA_0696>>",
      "formula": "\\label{eq:ctod}\n\\begin{aligned}\n     \\mH(\\theta(j,0))\\vc_i &= \\mH(\\theta(j,1))\\mR(-2i\\pi/m)\\vc_0 \\\\\n     &= \\mH(\\theta(j,0))\\mR(-2i\\pi/m)\\mH(\\pi/m)\\vd_0 \\\\\n      &= \\mH(\\theta(j,0))\\mH(\\theta(i,1))\\vd_0 \\\\\n     &= \\mR( \\theta(j,0) - \\theta(i,1))\\vd_0 \\\\\n     &= \\mR(2(i+j)\\pi/m)\\vd_0 = \\vd_{i - j \\bmod m},\n\\end{aligned}",
      "has_error": true,
      "error_type": "sign_flip",
      "error_description": "In the final step, R(2(i+j)π/m) applied to v_d0 should yield v_d_{i + j (mod m)}, but the formula states v_d_{i - j (mod m)}",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 59.99
    },
    {
      "label": "<<FORMULA_0706>>",
      "formula": "\\vh_{i+1}^{(2)} = \\begin{cases}\n        \\mH(\\theta(x_{i+1}, 1))  \\vh_{i}^{(2)} = \\mH(\\theta(x_{i+1}, 1))  \\vc_{y_i} = \\vc_{x_{i+1} + y_i \\bmod m} = \\vc_{y_{i+1}}  \\text{ if } i \\bmod 2 = 1\\\\\n        \\mH(\\theta(x_{i+1}, 0))  \\vh_{i}^{(2)} = \\mH(\\theta(x_{i+1}, 0))  \\vd_{s_i} = \\vd_{x_{i+1} + y_i \\bmod m} = \\vd_{y_{i - 1}} \\text{ if } i \\bmod 2 = 0\n    \\end{cases}.",
      "has_error": true,
      "error_type": "index_change",
      "error_description": "In the even branch, d_{x_{i+1}+y_i \\bmod m} is incorrectly equated to d_{y_{i-1}} (should be d_{y_{i+1}}), and d_{s_i} should be d_{y_i}.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 49.03
    },
    {
      "label": "<<FORMULA_0703>>",
      "formula": "\\vh_1^{(2)} &= \\mH(\\theta(x_1, 1)) \\vh_0^{(2)} = \\mH(\\theta(x_1, 1))  \\vd_0  = \\vc_{x_1 \\bmod m} =  \\vc_{y_1}  \\\\\n    \\vh_2^{(2)}  &= \\mH(\\theta(x_2, 0)) \\vh_1^{(2)} = \\mH(\\theta(x_2, 0)) \\vc_{x_1 \\bmod m} = \\vd_{x_1 - x_2 \\bmod m} = \\vd_{y_2},",
      "has_error": true,
      "error_type": "sign_flip",
      "error_description": "In the second equality chain, the index is updated as x1 - x2 mod m instead of x1 + x2 mod m, which is inconsistent with modular addition and the later inductive step using addition.",
      "parse_success": true,
      "parse_strategy": "direct",
      "llm_response_time": 87.54
    }
  ]
}