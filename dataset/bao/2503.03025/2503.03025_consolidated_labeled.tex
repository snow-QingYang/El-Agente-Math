%%%%%%%% ICML 2025 EXAMPLE LATEX SUBMISSION FILE %%%%%%%%%%%%%%%%%

\documentclass{article}

% Recommended, but optional, packages for figures and better typesetting:
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{placeins}
\usepackage{balance}
\usepackage[bottom]{footmisc}

% hyperref makes hyperlinks in the resulting PDF.
% If your build breaks (sometimes temporarily if a hyperlink spans a page)
% please comment out the following usepackage line and replace
% \usepackage{icml2025} with \usepackage[nohyperref]{icml2025} above.
\usepackage{hyperref}


% Attempt to make hyperref and algorithmic work together better:
\newcommand{\theHalgorithm}{\arabic{algorithm}}

%\usepackage[ruled,vlined]{algorithm2e}

% Use the following line for the initial blind version submitted for review:
\usepackage[accepted]{icml2025}

\let\algorithmicrequire\relax
\let\algorithmicensure\relax
\let\algorithmicreturn\relax
\let\algorithmicreturn\relax
\let\algorithmiccomment\relax

\let\algorithmic\relax
\let\endalgorithmic\relax

\usepackage{algorithm}
\usepackage{algpseudocode}

% If accepted, instead use the following line for the camera-ready submission:
%\usepackage[accepted]{icml2025}

% For theorems and such
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bm}
\usepackage{comment}
\usepackage{booktabs}
\usepackage{makecell}


% if you use cleveref..
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREMS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\DeclareMathOperator*{\bx}{\mathbf{x}}
\DeclareMathOperator*{\diag}{\mathrm{diag}}
\DeclareMathOperator*{\by}{\mathbf{y}}
\DeclareMathOperator*{\bu}{\mathbf{u}}
\DeclareMathOperator*{\bv}{\mathbf{v}}
\DeclareMathOperator*{\Tr}{\mathbf{tr}}
\DeclareMathOperator*{\argmin}{\arg\min}
\DeclareMathOperator*{\argmax}{\arg\max}
\newcommand{\dee}{\,\mathrm{d}}
\newcommand{\mb}{\mathbf}
\newcommand{\msf}{\mathsf}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\vp}{\varphi}
\newcommand{\tht}{\theta}
\newcommand{\sig}{\sigma}
\newcommand{\ci}{\mathcal{I}}
\newcommand{\R}{\mathbb{R}}
%\DeclareMathOperator*{\argmin}{arg\,min}


\newcommand{\ourmethod}{\texttt{HiRef}}

\usepackage{xparse}

\NewDocumentCommand{\ourmethodFull}{s}{
\unskip
  \IfBooleanTF{#1}
    {Hierarchical refinement}% Capitalized version
    {hierarchical refinement}% Lowercase version
  \unskip
}

\newcommand{\ourmethodFullCap}
    {Hierarchical Refinement\xspace}

% Todonotes is useful during development; simply uncomment the next line
%    and comment out the line below the next line to turn off comments
%\usepackage[disable,textsize=tiny]{todonotes}
\usepackage[textsize=tiny]{todonotes}


% The \icmltitle you define below is probably too long as a header.
% Therefore, a short form for the running title is supplied here:
\icmltitlerunning{Hierarchical Refinement: Optimal Transport to Infinity and Beyond}

\begin{document}
%\balance 

\twocolumn[
\icmltitle{Hierarchical Refinement: Optimal Transport to Infinity and Beyond}

% It is OKAY to include author information, even for blind
% submissions: the style file will automatically remove it for you
% unless you've provided the [accepted] option to the icml2025
% package.

% List of affiliations: The first argument should be a (short)
% identifier you will use later to specify author affiliations
% Academic affiliations should list Department, University, City, Region, Country
% Industry affiliations should list Company, City, Region, Country

% You can specify symbols, otherwise they are numbered in order.
% Ideally, you should not use this facility. Affiliations will be numbered
% in order of appearance and this is the preferred way.
\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Peter Halmos}{xxx,equal}
\icmlauthor{Julian Gold}{xxx,yyy,equal}
\icmlauthor{Xinhao Liu}{xxx}
\icmlauthor{Benjamin J. Raphael}{xxx}
\end{icmlauthorlist}


\icmlaffiliation{xxx}{Department of Computer Science, Princeton University}
\icmlaffiliation{yyy}{Center for Statistics and Machine Learning, Princeton University}

\icmlcorrespondingauthor{Benjamin J. Raphael}{braphael@princeton.edu}

\icmlkeywords{Machine Learning, ICML}

\vskip 0.3in
]

\printAffiliationsAndNotice{\icmlEqualContribution}




\begin{abstract}
Optimal transport (OT) has enjoyed great success in machine learning as a principled way to align datasets via a least-cost correspondence, driven in large part by the runtime efficiency of the Sinkhorn algorithm \cite{sinkhorn}.
However, Sinkhorn has quadratic space and time complexity in the number of points, limiting scalability to larger datasets. Low-rank OT achieves linear complexity, but by definition, cannot compute a one-to-one correspondence between points. When the optimal transport problem is an assignment problem between datasets then an optimal mapping, known as the \emph{Monge map}, is guaranteed to be a bijection. In this setting, we show that the factors of an optimal low-rank coupling co-cluster each point with its image under the Monge map. We leverage this invariant to derive an algorithm, 
\emph{\ourmethodFullCap} %\emph{hierarchical refinement} 
(\ourmethod{}), that dynamically constructs a multiscale partition of each dataset using low-rank OT subproblems, culminating in the bijective Monge map. \ourmethodFullCap{} runs in log-linear time and linear space, retaining the advantages of low-rank OT while overcoming its limited resolution. We demonstrate the advantages of \ourmethodFullCap{} on several datasets, including ones containing over a million points, scaling full-rank OT to problems previously beyond Sinkhorn's reach.
\end{abstract}

\section{Introduction}
\label{intro}

Optimal transport (OT) is a mathematical framework for comparing probability distributions $\mu$ and $\nu$. Given a cost function $c$, the \emph{Monge problem} is to find a mapping $T$ transforming a distribution $\mu$ into $\nu$ (i.e. <<FORMULA_0001>>) with least-cost. A relaxation of this problem, called the \emph{Kantorovich problem}, instead seeks a least-cost coupling $\gamma$ between  $\mu$ and $\nu$. 
In the Kantorovich formulation, mass splitting is allowed and thus a solution always exists; in contrast, a Monge map between $\mu$ and $\nu$ may not exist. When a Monge map $T$ does exist, the solution to the Kantorovich problem is a coupling <<FORMULA_0002>> supported on its graph, and the Monge and Kantorovich problems coincide \cite{brenier1991polar}.

When $\mu$ and $\nu$ are discrete uniform measures on $n$ 
points
the optimal transport problem reduces to an assignment problem. Classical algorithms such as the Hungarian algorithm and Network Simplex \cite{Tarjan1997, Orlin1997}, solve this in cubic time. The Sinkhorn algorithm \cite{sinkhorn} solves the entropy-regularized Kantorovich problem with quadratic runtime, greatly expanding the applicability of computational OT. However, the Sinkhorn algorihtm requires quadratic space to store the coupling $\gamma$.
%, where an optimal coupling matrix $\mathbf{P} \in \mathbb{R}_+^{n \times m}$ is computed for datasets of size $n$ and $m$. 

In recent years, OT has found numerous applications in machine learning and across science, including: 
domain adaptation 
\cite{courty2014domain, solomon2015convolutional}, 
self-attention \cite{tay20a, sander22a, geshkovski2023mathematical},
computational biology \cite{schiebinger2019optimal, yang2020predicting, zeira2022PASTE, Bunne_2023, destot, klein2023moscot},
unpaired data translation \cite{KorotinLGSFB21, bortoli2024schrodinger, tong2024improving, klein2024generative}, and alignment problems in transformers and large language models \cite{melnyk2024distributional, li2024gilot}. The \emph{least-cost} principle of optimal transport is crucial for training high-quality generative models using  Schrödinger bridges, flow-matching, diffusion models, or  neural ordinary differential equations \cite{finlay2020trainneuralodeworld, tong2024improving,bortoli2024schrodinger, kornilov2024optimal,klein2024generative}. These models typically require millions to hundreds of millions of data-points to achieve high-performance at scale \cite{dalle}, limiting the scope of OT for generative modeling.


As modern datasets grow to have tens of thousands or even millions of points, the quadratic space and time complexity of Sinkhorn becomes increasingly prohibitive. 
This limitation is widely recognized in the machine learning literature, with \cite{bortoli2024schrodinger} noting that the quadratic complexity of optimal transport renders its application to modern datasets on the order of millions of points impractical. A number of approaches have been proposed to address scaling OT to massive datasets which avoid instantiating a full coupling matrix. Mini-batch OT \cite{genevay18learning} improves scalability, but incurs significant biases \cite{JMLR:v20:18-079, KorotinLGSFB21, fatras2021jumbot} as each mini-batch alignment is a poor representation of the global coupling.
Multiple works have investigated the theoretical properties of mini-batch estimators of the coupling \cite{fatras2020learning, fatras2021minibatch}, while others have attempted to mitigate this bias using partial or unbalanced OT that allows mass variation between mini-batches \cite{nguyen2021improving, fatras2021jumbot}. However, these approaches introduce additional hyperparameters to control the degree of unbalancedness, and ultimately remain biased, local approximations of the global coupling.

Neural optimal transport methods \cite{pmlr-v119-makkuva20a, Bunne_2023, fan2023neural, korotin2023neural, buzun2024expectile}, parametrize the Monge map as a neural network instead of materializing a quadratic coupling matrix. However, these methods have noted limitations recovering faithful maps \cite{KorotinLGSFB21}. 

%Other methods \cite{de2021diffusion, bortoli2024schrodinger} solve for a stochastic map through the Schr\"{o}dinger bridge problem, but do not solve the primal optimal transport problem directly.

%In general, maps realizing the minimum \eqref{eq:monge_prob} are called \emph{Monge maps}, and a flurry of recent work \cite{pmlr-v119-makkuva20a, Bunne_2023, fan2023neural, korotin2023neural, buzun2024expectile} 
%on neural OT is devoted to deriving such maps using neural networks (neural OT).


%Training large-scale generative models using  Schrödinger bridges, flow-matching, diffusion models, or  neural ordinary differential equations often requires millions to hundreds of millions of data-points to achieve high-performance \cite{dalle}. However, the \emph{least-cost} principle of optimal transport is essential for 


Another approach to improve space complexity of OT is to introduce a \emph{low-rank} constraint on the coupling matrix
in the Kantorovich problem. This has been done by parameterizing the coupling through a set of low-rank factors \cite{Scetbon2021LowRankSF,scetbon2022linear,scetbon2022lowrank,scetbon2023unbalanced,FRLC}
%. A related approach uses 
or by using a proxy objective for the low-rank problem, factoring the transport through a small number of anchor points \cite{forrow19a,lin2021making}. For a given rank $r$ these approaches have <<FORMULA_0003>> space complexity, enabling \emph{linear} time and space scaling. Low-rank OT has been used successfully on datasets on the order of $10^{5}$ samples with ranks on the order of $10^{1}$ \cite{scetbon2023unbalanced, FRLC,HMOT,klein2023moscot}, but computing \emph{full-rank} couplings between datasets of sizes on the order of $10^{5}$ and greater
has not yet been accomplished.

\vspace{-2mm}

\paragraph{Contributions} 
We introduce \ourmethodFullCap{} (\ourmethod{}), an algorithm to scalably compute a full-rank alignment between two equally-sized input datasets $\mathsf{X}$ and $\mathsf{Y}$ by solving a hierarchy of low-rank OT sub-problems. The success of this refinement is driven by a theoretical result, Proposition~\ref{prop:low_rank_monge_main}, stating that factors of an optimal low-rank coupling between $\mathsf{X}$ and $\mathsf{Y}$ co-cluster points $\mathsf{X}$ with their image under the Monge map. %$T(\mathsf{X}) = \mathsf{Y}$.
%relating $\mathsf{X}$ and $\mathsf{Y}$.
%= T(\mathsf{X})$. 
We use Proposition~\ref{prop:low_rank_monge_main} recursively to obtain increasingly fine partitions of $\mathsf{X}$ and $\mathsf{Y}$. At each scale, the solutions to low-rank OT sub-problems 
%place 
are bijections between the partitions of $\mathsf{X}$ and $\mathsf{Y}$. Iterating to the finest scale gives a bijection between $\mathsf{X}$ and $\mathsf{Y}$.

\ourmethodFullCap\ constructs a \emph{multiscale partition} of each dataset, and thus is related to \cite{gerber2017multiscale}, which introduced a general framework for multiscale optimal transport using such partitions, and the earlier work of \cite{merigot2011multiscale}. 
Unlike \cite{merigot2011multiscale, gerber2017multiscale}, \ourmethodFullCap\ (i) does not assume multiscale partitions for each dataset are given, instead constructing them on the fly; and (ii) operates intrinsically to the data, without a mesh or anchor points in the ambient space of the data, avoiding the curse of dimensionality.

We demonstrate that \ourmethodFullCap\ computes OT maps efficiently in high-dimensional spaces, often matching or even outperforming Sinkhorn in terms of primal cost. Moreover, \ourmethod{} has linear space complexity and time complexity scaling log-linearly in the dataset size. Unlike low-rank OT, \ourmethodFullCap\ places $\mathsf{X}$ and $\mathsf{Y}$ in bijective correspondence. \ourmethodFullCap\ scales to over a million points, enabling the use of OT on massive datasets without incurring the bias of mini-batching.
\section{Background and Related Work}
Suppose <<FORMULA_0004>> and <<FORMULA_0005>> are datasets in the same metric space <<FORMULA_0006>>. Let <<FORMULA_0007>> be a cost function. This cost $c$ is often assumed to satisfy strict convexity or to be a metric. Datasets $\mathsf{X}$ and $\mathsf{Y}$ are represented as discretely supported probability measures <<FORMULA_0008>> and <<FORMULA_0009>> for probability vectors <<FORMULA_0010>> and <<FORMULA_0011>>. Throughout, $\Delta_k$ denotes the \emph{$k$-simplex} 
<<FORMULA_0012>>, 
the set of probability vectors of length $k$.

\paragraph{Monge Problem}
Optimal transport has its origin in the \emph{Monge problem} \cite{monge1781memoire}, concerned with finding an optimal map <<FORMULA_0013>> pushing $\mu$ forward to $\nu$:
<<FORMULA_0014>>
Above, <<FORMULA_0015>> is the pushforward of $\mu$ under $T$, the measure on $\mathsf{Y}$ with 
<<FORMULA_0016>> for 
any (measurable) set <<FORMULA_0017>>. In general, a Monge map may not exist (e.g. if <<FORMULA_0018>>). However, when <<FORMULA_0019>> and <<FORMULA_0020>> are uniform then the Monge problem becomes the \emph{assignment problem} and has a bijective solution \cite{Thorpe2017IntroductionTO}.

\paragraph{Kantorovich Problem}
The \emph{Kantorovich problem} \cite{kantorovich1942transfer} was introduced as a relaxation of the Monge problem. In contrast to the Monge problem, the Kantorovich problem allows mass-splitting and a solution is always guaranteed to exist. 
Define the \emph{transport polytope} $\Pi_{\mathbf{a}, \mathbf{b}}$ as the following set of coupling matrices
<<FORMULA_0021>>
respectively with left (or ``source'') marginal $\mathbf{a}$ and with right (or ``target'') marginal $\mathbf{b}$. 
For the cost <<FORMULA_0022>>, define the cost matrix $\mathbf{C}$ by <<FORMULA_0023>>. In this discrete setting, the Kantorovich problem seeks a least cost coupling matrix <<FORMULA_0024>> between the probability vectors <<FORMULA_0025>> associated to each measure <<FORMULA_0026>>:
<<FORMULA_0027>>
The optimal value <<FORMULA_0028>> of \eqref{eq:kantorovich_problem} is called the \emph{$c$-Wasserstein distance} between $\mu$ and $\nu$.

\paragraph{Sinkhorn Algorithm and the $\epsilon$-schedule} 
The Sinkhorn algorithm \cite{sinkhorn} relaxes the classical linear-programming formulation of optimal transport by solving an entropy regularized version of \eqref{eq:kantorovich_problem},
<<FORMULA_0029>>
where <<FORMULA_0030>> is the Shannon entropy, and the parameter <<FORMULA_0031>> is the regularization strength. The Sinkhorn algorithm improved the <<FORMULA_0032>> time complexity of classical techniques used for OT such as the Hungarian algorithm \cite{Kuhn1955Hungarian} and Network Simplex \cite{Orlin1997, Tarjan1997} to <<FORMULA_0033>> \cite{luo2023improved}. As <<FORMULA_0034>>, the optimal coupling $\mathbf{P}^{\star, \epsilon}$ for \eqref{eq:ent_wasserstein} converges to a sparse optimal coupling for \eqref{eq:kantorovich_problem} at an extremal point of the transport polytope (c.f. \cite{peyre2019computational}). 
%The convergence of optimal transport from an initial feasible condition such as the product measure $\mathbf{a} \otimes \mathbf{b}$ to a sparse, optimal plan on the Birkhoff polytope, depends greatly on $\epsilon$. In the limit $\epsilon \to 0$, $\mathbf{P}^{\epsilon}$ converges to the optimal sparse plan . 
However, the number of iterations required scales as <<FORMULA_0035>>, diverging as $\epsilon$ decreases. A technique used to improve this scaling is the $\epsilon$-schedule, an adaptive, monotone-decreasing and step-dependent set of entropy parameters <<FORMULA_0036>>. This anneals Problem~\ref{eq:ent_wasserstein} from high-entropy to low-entropy, gradually driving a dense initial condition to a sparse solution with a <<FORMULA_0037>> rate \cite{Chen2023}.

\begin{comment}
As $\epsilon$ corresponds to a temperature parameter in the Sinkhorn factorization <<FORMULA_0038>> \cite{sinkhorn, sinkhorn1966relationship}, this \emph{annealing} from high-temperature to low-temperature gradually drives a dense initial condition to a sparse solution with a <<FORMULA_0039>> rate \cite{Chen2023}.
\end{comment}

\paragraph{Low-rank Optimal Transport}

%(\textbf{Diagonal Factorization} + \textbf{Latent-Coupling (LC) Factorization})

The nonnegative rank <<FORMULA_0040>> of a nonnegative matrix <<FORMULA_0041>> is the smallest number of nonnegative rank-1 matrices summing to $\mathbf{M}$; i.e. <<FORMULA_0042>> is the smallest integer $z$ such that there exist nonnegative vectors <<FORMULA_0043>> and <<FORMULA_0044>> satisfying <<FORMULA_0045>>.
%defined as $\mathrm{rk}_+(\mathbf{M}) = \min_z  \mathbf{M} = \sum_{i=1}^{z} \mathbf{q}_{i} \mathbf{r}_{i}^{\top} \mathbf{q}_{i} \mathbf{r}_{i}^{\top} \succcurlyeq 0 \}$. 
Let <<FORMULA_0046>> be the set of rank-$r$ couplings. The low-rank Wasserstein problem for general cost matrix $\mathbf{C}$ is:
<<FORMULA_0047>>
From \cite{cohen1993nonnegative}, each <<FORMULA_0048>> may be decomposed as 
\vspace{-4mm}
<<FORMULA_0049>> 
\vspace{-6mm}

where <<FORMULA_0050>>, <<FORMULA_0051>> and <<FORMULA_0052>>. This factorization was introduced to optimal transport by \cite{Scetbon2021LowRankSF} in the context of the general low-rank problem \eqref{eq:lora_wass}. The  factors $\mathbf{Q}$ and $\mathbf{R}$  constitute co-clusterings of datasets $\mathsf{X}$ and $\mathsf{Y}$ onto the \emph{same} set of $r$ components. Other factorizations have recently been proposed \cite{FRLC}, using <<FORMULA_0053>> and an intermediate latent coupling $\mathbf{T}$ 
to solve \eqref{eq:lora_wass} where $\mathsf{X}$ and $\mathsf{Y}$ have $r_{1}$ and $r_{2}$ components, respectively.

\paragraph{Hierarchical and Multiscale Approaches to OT}

%\citep{gerber2017multiscale, schmitzer2016sparse, kassraie2024progressive}
Hierarchical optimal transport \cite{schmitzer2013hierarchical} 
is a variant of OT modeling data and transport
at two scales, using Wasserstein distances as
the 
coarse-scale 
ground costs. 
It has been applied to document representation \cite{yurochkin2019hierarchical}, domain adaptation \cite{el2022hierarchical}, sliced Wasserstein distances \cite{bonneel2015sliced, nguyen2022hierarchical} and to give a discrete formulation of transport between Gaussian mixture models \cite{chen2018optimal, delon2020wasserstein}. These works 
build interpretable,
coarse-grained structure into a single coupling, rather than 
solving for a sequence of couplings at progressively finer scales as in the present work.

Multiscale approaches to OT 
generalize hierarchical OT to a progression of scales. Building on the semidiscrete approach of \cite{aurenhammer1998minkowski},  \cite{merigot2011multiscale} uses Lloyd's algorithm to progressively coarse-grain the target measure.
%, propagating couplings computed between source and coarse-grained target to initialize an optimization at the next scale. 
More recently, 
using a regular family of multiscale partitions (Definition~\ref{def:reg_fam_msp}) on each dataset, \cite{gerber2017multiscale} formalize a general  hierarchical approach to the Kantorovich problem \eqref{eq:kantorovich_problem}. They propose: (i) solving a Kantorovich problem between the coarsest partitions of $\mathsf{X}$ and $\mathsf{Y}$ in their respective multiscale families; and (ii) propagation of the optimal coupling at scale <<FORMULA_0054>> to initialize the optimization at scale <<FORMULA_0055>>. They take as input a chain of partitions and measures across scales <<FORMULA_0056>> and <<FORMULA_0057>> where each dataset <<FORMULA_0058>> is identified with the trivial partitions <<FORMULA_0059>> and <<FORMULA_0060>>. 
At the finest scale $\kappa$, \cite{gerber2017multiscale} recover the original datasets and a near optimal coupling for \eqref{eq:kantorovich_problem}. 


A naive implementation of the above idea requires quadratic memory complexity, but \cite{gerber2017multiscale} propose several propagation strategies to mitigate this, following \citep{glimm2013iterative, oberman2015efficient, schmitzer2016sparse}. These strategies use the optimal coupling at scale $t$ to restrict the support of the coupling computed at the next scale using local optimality criteria.
%for OT \cite{schmitzer2016sparse}. 
In the next section, we give our own such criterion, Proposition~\ref{prop:low_rank_monge_main}. 


\begin{comment}
In particular, the potential refinement strategy employed by \cite{glimm2013iterative} uses the variables in the dual problem to \eqref{eq:kantorovich_problem} for a local optimality criterion, carefully choosing the support of couplings at subsequent scales to ensure optimality of the coupling at the finest scale. In a similar spirit, \cite{schmitzer2016sparse} introduced shielding neighborhoods to provide local optimality criteria for discrete OT. These local optimality criteria for discrete OT parallel Brenier's theorem \cite{brenier1991polar} in the continuous setting, and in the next section, we give our own such criterion, Proposition~\ref{prop:low_rank_monge_main}. 
\end{comment}


\begin{figure}[tbp]
% \vskip 0.2in
\centerline{\includegraphics[width=\linewidth]{images/fig1.png}}
\caption{
\ourmethodFullCap algorithm: low-rank optimal transport is used to progressively refine partitions at the previous scale, with the coarsest scale partitions denoted <<FORMULA_0061>>, and the finest scale partitions <<FORMULA_0062>> corresponding to the individual points in the datasets.}
\label{fig:fig1}
\end{figure}


\section{Hierarchical Refinement}

\subsection{Low-rank optimal transport co-clusters source-target pairs under the Monge map}
%as a co-clustering of $(\mathsf{X}, T(\mathsf{X}))$

We first show that under a few assumptions,  the optimal low-rank factors <<FORMULA_0063>> for a \emph{variant} of the low-rank Wasserstein problem \eqref{eq:lora_wass} have qualities suited to our refinement strategy. Specifically, we parameterize low-rank couplings $\mathbf{P}$ of rank-$r$ using the factorization <<FORMULA_0064>> of \cite{Scetbon2021LowRankSF}, fixing <<FORMULA_0065>> to be uniform. Define the following variant of \eqref{eq:lora_wass}: 
<<FORMULA_0066>>
Proposition~\ref{prop:low_rank_monge_main} below is the main structural result behind \ourmethodFullCap{}. It says that when optimal $\mathbf{Q}^\star$ and $\mathbf{R}^\star$ for \eqref{eq:lora_wass_variant} correspond to hard-clusterings (partitions) of each dataset, given by clustering functions <<FORMULA_0067>>, one has <<FORMULA_0068>>, where <<FORMULA_0069>> is a Monge map.

%Proposition~\ref{prop:low_rank_monge_main}. 
\begin{proposition}[Optimal low-rank factors co-cluster Monge pairs]
\label{prop:low_rank_monge_main}
Let <<FORMULA_0070>> with <<FORMULA_0071>>, with cost matrix $\mb{C}$ that is strictly $r$-Monge separable (Definition~\ref{def:r_Monge_sep}).
Let <<FORMULA_0072>> be uniform so that  a Monge map <<FORMULA_0073>> exists. 
If <<FORMULA_0074>> are minimizers of \eqref{eq:lora_wass_variant} and correspond to clustering functions <<FORMULA_0075>>, 
then for all <<FORMULA_0076>> one has <<FORMULA_0077>>
\end{proposition}

The proof of Proposition~\ref{prop:low_rank_monge_main} is in two steps. First, we use the existence of a Monge map and its coupling $\mb{P}^\dagger$ to permute the cost $\mb{C}$ to cost $\mb{C}^\dagger$ (Definition~\ref{def:monge_reg})
for which the identity matrix is a Monge map. Second, supposing that strict $r$-Monge separability (Definition~\ref{def:r_Monge_sep}) holds, we show the solution to Problem~\ref{eq:lora_wass_variant} with cost $\mb{C}^\dagger$ is symmetric, so that <<FORMULA_0078>>. Returning to the coordinate frame of the original cost $\mb{C}$, we find that <<FORMULA_0079>>, implying Proposition~\ref{prop:low_rank_monge_main}. We note that when <<FORMULA_0080>>, optimal <<FORMULA_0081>> are hard-partitions (Lemma~\ref{lem:supp_reduction_lemma}) automatically satisfying one of the assumptions of Proposition~\ref{prop:low_rank_monge_main}.

 %First, supposing that the optimal coupling $\mb{P}^{\dagger} \in  \arg\min_{\,\,\mb{P} \in \Pi_{\bm{a},\bm{b}} } \left\langle \mb{C}, \mb{P} \right\rangle_{F}$ exists is a permutation by the Birkhoff-von Neumann theorem \cite{birkhoff1946tres}, one can express Problem~\ref{eq:lora_wass_variant} as a minimization with respect to a cost

%supposing one has oracle access to 






\begin{comment}
The assumption that the datasets are of size $2^k$ is without loss of generality: for a dataset of size $n$, let <<FORMULA_0082>> and add <<FORMULA_0083>> ``dummy'' points at infinite distance from <<FORMULA_0084>>, and mutual distance zero.
%to invoke the same result for general $n$.
\end{comment}



\subsection{Hierarchical Refinement Algorithm}

The \ourmethodFullCap\ algorithm (Algorithm~\ref{alg:hr_ot}) uses 
Proposition~\ref{prop:low_rank_monge_main} 
%is central to the  -- it 
to guarantee that each low-rank step co-clusters the datasets optimally, in that $\mathbf{x}$ and <<FORMULA_0085>> 
%will be 
are assigned the same label by $\mathsf{q}^\star$ and $\mathsf{r}^\star$.
Using the same label set to partition $\mathsf{X}$ and $\mathsf{Y}$ automatically places the blocks of each partition in bijective correspondence. 
One then recurses on each pair of corresponding blocks (which we call a \emph{co-cluster}) at the previous scale, until all blocks have size one. This guarantee holds despite that optimal <<FORMULA_0086>> for \eqref{eq:lora_wass_variant} may not constitute an optimal triple <<FORMULA_0087>> for the original low-rank problem \eqref{eq:lora_wass} under the \cite{Scetbon2021LowRankSF} factorization.

A hierarchy-depth $\kappa$ denotes the total number of times Algorithm~\ref{alg:hr_ot} refines the initial trivial partitions <<FORMULA_0088>>. The effective rank at scale $t$ is <<FORMULA_0089>>, given 
rank-annealing schedule <<FORMULA_0090>> for which $\rho_\kappa$ divides $n$. The base rank is
<<FORMULA_0091>>. Note that <<FORMULA_0092>> is also the size of each partition at scale $t$: <<FORMULA_0093>>, and that any sequence of any factorization of $n$ corresponds to a rank-annealing schedule.
%to any dataset size $n$ which can be non-trivially factored. 
%For an $r$-Monge separable cost and dataset of size $n = r^{\kappa}$, we show that \ourmethodFullCap{} is guaranteed to recover the Monge map.

\begin{proposition}
For any $n$, there exists a rank-schedule <<FORMULA_0094>> factorizing $n$ such that all partitions of Algorithm~\ref{alg:hr_ot} at level <<FORMULA_0095>> satisfy strict $r_{t+1}$-Monge separability (Definition~\ref{def:r_Monge_sep}). Let $\mathrm{LROT}$ denote an optimal rank-$r$ solver for (\ref{eq:lora_wass_variant}) over hard-partitions. For any satisfying rank-schedule, the map returned by Algorithm~\ref{alg:hr_ot} is optimal and supported on the graph of the Monge map <<FORMULA_0096>>.
\end{proposition}
\begin{proof}
Existence follows from the trivial <<FORMULA_0097>> rank-schedule. For any schedule <<FORMULA_0098>> satisfying Monge separability, applying the invariant of Proposition~\ref{prop:low_rank_monge_main} inductively on $t$ to level $\kappa$ yields $n$ tuples <<FORMULA_0099>> containing each <<FORMULA_0100>> and its image <<FORMULA_0101>> under the Monge map.
\end{proof}
If the black-box subroutine $\mathrm{LROT}$ in Algorithm~\ref{alg:hr_ot} solves \eqref{eq:lora_wass_variant} optimally, then \ourmethodFullCap\ is guaranteed to recover a Monge map. In practice, we implement $\mathrm{LROT}$ using the low-rank solver \cite{FRLC} and enforce that inner marginal $\mathbf{g}$ is uniform.
%Observe that the assumption that the datasets are of size $ r^\kappa$ is without loss of generality: for a dataset of size $n$, let $q = \min \left\{r^{t} \mid t \in \mathbb{N}, r^{t} > n \right\}$ and add $q-n$ ``dummy'' points at infinite distance from $\mathsf{X}, \mathsf{Y}$, and mutual distance zero.
\begin{comment}
\begin{proposition}
Suppose <<FORMULA_0102>> and we have an $r$-Monge separable (Definition~\ref{def:r_Monge_sep}) cost. Let $\mathrm{LROT}$ denote an optimal rank-$r$ solver for (\ref{eq:lora_wass_variant}) over hard-partitions. Then, the bijective map returned by Algorithm~\ref{alg:hr_ot} is optimal and supported on the graph of the Monge map <<FORMULA_0103>>.
\end{proposition}
\begin{proof}
Applying the invariant of Proposition~\ref{prop:low_rank_monge_main} inductively after <<FORMULA_0104>> levels of refinement 
yields 
%implies a return of 
a set of tuples <<FORMULA_0105>> containing each <<FORMULA_0106>> and its corresponding image <<FORMULA_0107>> under Monge map <<FORMULA_0108>>.
\end{proof}

If the black-box subroutine $\mathrm{LROT}$ in Algorithm~\ref{alg:hr_ot} solves \eqref{eq:lora_wass_variant} optimally, then \ourmethodFullCap\ is guaranteed to recover a Monge map. In practice, we implement $\mathrm{LROT}$ using the low-rank solver \cite{FRLC} enforcing that inner marginal $\mathbf{g}$ is uniform. Observe that the assumption that the datasets are of size <<FORMULA_0109>> is without loss of generality: for a dataset of size $n$, let <<FORMULA_0110>> and add <<FORMULA_0111>> ``dummy'' points at infinite distance from <<FORMULA_0112>>, and mutual distance zero.
\end{comment}

\begin{algorithm}[htb]
\caption{Hierarchical Refinement}
\label{alg:hr_ot}
\begin{algorithmic}[1]
\Require 
  \textbf{Data} <<FORMULA_0113>>; 
  \textbf{Low-rank OT solver} <<FORMULA_0114>>;
  \textbf{Rank schedule} <<FORMULA_0115>>;
  \textbf{Base rank} \(r_{\text{base}} \) (=1).
\Statex

\noindent \textbf{Initialize:}
\State <<FORMULA_0116>>, <<FORMULA_0117>>
\While{<<FORMULA_0118>> \textbf{ such that } \\
        <<FORMULA_0119>>}
    \State <<FORMULA_0120>>
    \For{<<FORMULA_0121>>}
        \If{ <<FORMULA_0122>> }
            \State <<FORMULA_0123>>
        \Else
            %\State Define empirical measures:
            \State <<FORMULA_0124>>
            \State <<FORMULA_0125>>
            \State <<FORMULA_0126>>
            \State <<FORMULA_0127>>
            \For{<<FORMULA_0128>>}
                \State <<FORMULA_0129>>
                \State <<FORMULA_0130>>
                \State <<FORMULA_0131>>
            \EndFor
            \State \Comment{\scriptsize<<FORMULA_0132>>\normalsize}
            \EndIf
    \EndFor
    \State <<FORMULA_0133>>
\EndWhile

\State \textbf{Output:} 
  <<FORMULA_0134>> 
  \quad \Comment{Mapped pairs.}
\end{algorithmic}
\end{algorithm}

%diagonalizing its output to obtain $(\mathbf{Q}, \mathbf{R}, \mathbf{g})$, and setting the mirror-descent step-size parameter $\tau_{\mathrm{in}} \uparrow \infty$ to enforce the uniform constraint on the inner marginal $\mathbf{g}$.


Let $\Gamma_{t,q}$ denote the $q$-th co-cluster at scale $t$ generated by \ourmethodFullCap{}:
<<FORMULA_0135>>
where <<FORMULA_0136>>, <<FORMULA_0137>>, and define the co-clustering $\Gamma_t$ at scale $t$ by:
<<FORMULA_0138>>
At scale <<FORMULA_0139>>, \ourmethodFullCap\ refines $\Gamma_{t}$ to $\Gamma_{t+1}$ by running a rank $r_{t+1}$ low-rank optimal transport problem between uniform <<FORMULA_0140>> and measures supported on each pair <<FORMULA_0141>> in $\Gamma_t$ for <<FORMULA_0142>>, yielding factors specific to this <<FORMULA_0143>>:
<<FORMULA_0144>>
For each <<FORMULA_0145>> we use the <<FORMULA_0146>> from \eqref{eq:QR_gets} to 
co-cluster $\mathsf{X}_q^{(t)}$ with $\mathsf{Y}_q^{(t)}$ using $r_{t+1}$ labels. Within this pair, each <<FORMULA_0147>> is assigned a label <<FORMULA_0148>> by taking the argmax over the $i$-th row of $\mathbf{Q}$, and likewise each <<FORMULA_0149>> is assigned the argmax over the $j$-th row of $\mathbf{R}$. This corresponds to the $\mathrm{Assign}$ step in Algorithm~\ref{alg:hr_ot}, and coincides with the hard assignment of $\mathsf{q}^\star$ and $\mathsf{r}^\star$ for an optimal <<FORMULA_0150>> (Lemma~\ref{lem:supp_reduction_lemma}).


The uniform constraint <<FORMULA_0151>> in \eqref{eq:lora_wass_variant} enforces an even split of the dataset, which by Lemma~\ref{lem:supp_reduction_lemma} ensures a partition at optimality (for <<FORMULA_0152>>).
Repeating for all <<FORMULA_0153>>, one obtains a co-clustering with $r_{t+1}$ components within each co-cluster at the previous scale, leading to a total of <<FORMULA_0154>> co-clusters at scale <<FORMULA_0155>> (Fig.~\ref{fig:fig1}). If the base-case rank $r_{\mathrm{base}}$ is one, Algorithm~\ref{alg:hr_ot} returns a bijection between $\mathsf{X}$ and $\mathsf{Y}$ as a collection of $n$ tuples. 

%We emphasize that we do not instantiate the transport plans $\mathbf{P}^{(t)}$ implicit at each scale $t$; these ``implicit'' transport plans may be block-diagonalized, with $\rho_{t}$ square blocks for each co-clustering, defined by by 
Note that \ourmethodFullCap\ defines an implicit hierarchy of block-couplings at each scale $t$.
\begin{definition}[Hierarchical block-coupling]
\label{def:hbc}
    For each scale <<FORMULA_0156>>, given the \ourmethodFullCap\ co-cluster partition $\Gamma_{t}$, the \emph{hierarchical block-coupling} at scale $t$ is defined by the matrix
\vspace{-4mm}
<<FORMULA_0157>>
\end{definition}
Without loss of generality, $\mathbf{P}^{(t)}$ may be block diagonalized into $\rho_{t}$ square blocks, as discussed in Appendix~\ref{sec:supp_pfs} (see Equation~\eqref{eq:supp_P_corresp_t}). By Proposition~\ref{prop:low_rank_monge_main}, for any rank-schedule $(r_{j} )_{j=1}^{\kappa}$ satisfying Monge separability, the final $\mathbf{P}^{(\kappa)}$ corresponds to an optimal coupling supported on the graph of the Monge map $T^{\star}$, <<FORMULA_0158>>. While these intermediate couplings are never instantiated, one can still use them to define a transport cost <<FORMULA_0159>> at each scale. In Appendix~\ref{prop:one_step_bound}, we show the following bounds on the cost difference across scales. 

\begin{proposition}
\label{prop:one_step_bound_main}
Let <<FORMULA_0160>> be a strictly-convex and Lipschitz cost function, let <<FORMULA_0161>> be a rank-schedule, %sample size $n$, and step $t < \kappa$. 
and let $\mathbf{P}^{(t)}$ denote the coupling defined in \eqref{eq:hbc}, obtained from step $t$ of Algorithm~\ref{alg:hr_ot}. Define <<FORMULA_0162>>. Then, 
%the difference in cost between iterations of refinement is
\vspace{-4mm}
<<FORMULA_0163>>
where $q$ indexes co-clusters $\Gamma_{t,q}$ at scale $t$, defined in \eqref{eq:gamma_t_q_def}.
\end{proposition}

\vspace{-2mm}
Thus, the lower-bound implies that each step of refinement improves the coarse partition, and the upper-bound implies that the difference in solution value is bounded above by a factor depending on the Lipschitz constant and the mean diameter of the coarse partitions at each level $t$. The proof of Proposition~\ref{prop:one_step_bound_main} roughly follows that of Proposition~1 of  \cite{gerber2017multiscale}. In Remark~\ref{rmk:conditional_ub}, we discuss how Proposition~\ref{prop:one_step_bound_main} compares, noting that our result makes fewer geometric assumptions on our multiscale partitions <<FORMULA_0164>> and <<FORMULA_0165>> and therefore does not quantify the rate of decay of <<FORMULA_0166>>.

%Additionally, in Remark~\ref{remark:no_gain} we note under constant cost within a co-cluster this inequality becomes tight, so that \ourmethod{} offers no gain.


\subsection{On the Rank-Annealing Schedule}\label{sec:rank_anneal}

As observed by \cite{forrow19a, Scetbon2021LowRankSF}, rank behaves like a temperature parameter,
inverse to the strength $\epsilon$
of entropy regularization. 
%The \emph{rank-annealing} technique used in \ourmethodFullCap\ thus parallels the $\epsilon$-schedule, annealing from coarse higher-temperatures $\epsilon \to \infty$ to fine lower-temperatures $\epsilon \to 0$ to yield a sparse coupling matrix. 
The correspondence between small $\epsilon$ and large rank implies that
%, and large $\epsilon$ to low-rank,  
annealing in the parameter $\epsilon$ 
is, from the perspective of rank, analogous 
to 
%of entropy-regularized OT, %i.e. gradually decreasing $\epsilon \downarrow 0$ according to some schedule,
initializing the optimization at a low-rank coupling,
and then gradually increasing the rank constraint 
from low to full. 
In \ourmethodFullCap{}, this gradual rank increase is accomplished
implicitly. At each scale <<FORMULA_0167>> the implicit coupling $\mathbf{P}^{(t)}$ is 
made explicit in the hierarchical block coupling defined in equation~\eqref{eq:hbc}. 
A rank-annealing schedule <<FORMULA_0168>> describes the sequence of 
multiplicative factors by which the rank of this 
explicit coupling will increase at successive scales.
The partial products of these, denoted 
<<FORMULA_0169>>, are the ranks of the couplings <<FORMULA_0170>>. Note that small values of $r_{i}$ generate coarse partitions of the points at the next scale, while large values of $r_{i}$ generate finer partitions at the next scale.

We now turn to the question of how to efficiently choose such a schedule
under given memory constraints. For an integer $n$, 
%the number of points per sub-problem decays at the rate at which each sub-division occurs, so that 
Algorithm~\ref{alg:hr_ot} has log-linear complexity for depth <<FORMULA_0171>> (Section~\ref{sec:complexity}). However, the large constants required by low-rank OT in practice encourage minimizing the number of calls to $\mathrm{LROT}$ as a subroutine, so that if memory permits, it may be advantageous to decrease the depth by storing couplings of higher rank. If desired, memory constraints can be enforced by imposing a maximum rank <<FORMULA_0172>> for all <<FORMULA_0173>> to ensure \ourmethodFullCap{} only requires <<FORMULA_0174>> space at each step. Thus, we seek factorizations with \emph{minimal} partial sums of ranks while remaining below a desired memory-capacity: 
%$\label{eq:rank_opt} \min_{(r_{i})_{i=1}^{\kappa}} \sum_{j=1}^{\kappa} \rho_{j}   \, \textrm{ s.t. } \, \rho_{\kappa} = n, \, r_{i} \leq r_{\max} \, .$
\vspace{-3mm}
<<FORMULA_0175>>
\vspace{-3mm}

The above optimization assumes a base-rank $r_{\mathrm{base}}$ of $1$; we describe how to handle the general case in Appendix~\ref{sect:rank_schedule}. 
%Here, we remark that 
Importantly, the recursive structure <<FORMULA_0176>>
\begin{comment}
<<FORMULA_0177>>
\end{comment}
enables a dynamic programming approach to \eqref{eq:rank_opt}, storing a table of factors up to $r_{\max}$ to optimize \eqref{eq:rank_opt} in <<FORMULA_0178>> time. 
Assuming <<FORMULA_0179>> are small constants chosen to ensure that all matrices can fit within memory, determining the optimal rank-schedule with respect to <<FORMULA_0180>> is a simple linear-time procedure. 

\begin{figure}[!t]
\centerline{\includegraphics[width=\linewidth]{images/method_costs_samples_log.png}}
\caption{Primal OT cost for varying sample size on the synthetic half-moon S-curve dataset of \cite{buzun2024expectile} for \ourmethod, Sinkhorn, and ProgOT}
\label{fig:sample_complexity}
\end{figure}

\subsection{Complexity and Scaling of Hierarchical Refinement}\label{sec:complexity}
For two datasets <<FORMULA_0181>> of size $n$, the space complexity of \ourmethodFullCap{} is <<FORMULA_0182>>, since at each level, one must store $\Gamma_{t}$ which is a set of subsets of $\mathsf{X}$ and $\mathsf{Y}$. To derive the time-complexity of \ourmethodFullCap{}, note that if <<FORMULA_0183>>, a rank-$r$ schedule at each layer requires $\frac{n}{r}$ instances of $\mathrm{LROT}$ over rapidly decaying dataset sizes. The complexity of low-rank OT \cite{Scetbon2021LowRankSF, scetbon2022linear, FRLC} is linear  (<<FORMULA_0184>>) for a constant <<FORMULA_0185>> dependent on $B$ the number of inner Sinkhorn \cite{FRLC} or Dykstra \cite{Scetbon2021LowRankSF} iterations, $L$ the number of mirror-descent steps, $r$ the rank of the coupling, and $d$ the rank of the factorization of the cost matrix $\mathbf{C}$. In this setting, for $n$ a power of $r$, the runtime of Algorithm~\ref{alg:hr_ot} is given by the sum <<FORMULA_0186>> for <<FORMULA_0187>>, achieving \emph{linear} space with \emph{log-linear} time for constant ranks <<FORMULA_0188>>.


%In the case that $d$ is not a small constant, i.e. where one does not assume a low-rank factorization of cost matrix $\mathbf{C} = \mathbf{U V}^{\top}$, the time and space complexity becomes quadratic in $n$, like Sinkhorn.

In cases where the cost matrix does not admit a low-rank factorization <<FORMULA_0189>>, i.e., when <<FORMULA_0190>>, one requires <<FORMULA_0191>> space to store the cost matrix and \ourmethodFullCap{} exhibits time complexity <<FORMULA_0192>>, as in Sinkhorn. For kernel costs such as squared Euclidean cost, as noted in \cite{Scetbon2021LowRankSF}, one may efficiently compute a <<FORMULA_0193>> dimensional factorization where $d$ is the ambient dimension, to achieve log-linear scaling with exact distances. We also use the sample-linear algorithm of \cite{pmlr-v99-indyk19a} to compute approximate factorizations for distances <<FORMULA_0194>> satisfying metric properties such as the triangle inequality (e.g. Euclidean distance, see Appendix~\ref{sec:low_rank_dist}). At each level, pairing such sample-linear approximations with each low-rank step only requires <<FORMULA_0195>> time. We observe this scaling empirically, as reported in Fig.~\ref{fig:runtime_scaling}.



\section{Experiments}

We benchmark \ourmethodFullCap{} (\ourmethod{}) against the full-rank OT methods Sinkhorn \cite{sinkhorn},
%, the de facto standard for computing OT alignments,
ProgOT \cite{kassraie2024progressive}, and mini-batch OT \cite{genevay18learning, fatras2020learning, fatras2021minibatch}. We additionally benchmark against the low-rank OT methods LOT \cite{Scetbon2021LowRankSF} and FRLC \cite{FRLC}. We use the default implementations of Sinkhorn, ProgOT, and LOT in the high-performance \texttt{ott-jax} library \cite{cuturi2022optimal}. In particular, Sinkhorn is run with the default entropy regularization parameter of <<FORMULA_0196>>. We also benchmark against the multiscale method MOP \cite{gerber2017multiscale}, which requires multiscale partitions of the input datasets -- akin to a family of dyadic cubes across scales -- to compute alignments. This leads to a transport cost that depends on the choice of this partition. For simplicity, we choose the default partitions of MOP which are computed from the GMRA (Geometric Multi-Resolution Analysis) R package.

\begin{figure*}[!t]
% \vskip 0.2in
\centerline{\includegraphics[width=.6\linewidth]{images/synth_ex1.pdf}}
\caption{Comparison of the \ourmethodFullCap\ Mapping, the Sinkhorn Barycentric Map, and an optimal map computing using dual revised simplex for the \textbf{a.} Half-moon and S-curve dataset \cite{buzun2024expectile} of 4096 points (512 points for dual revised simplex) and \textbf{b.} Checkerboard dataset \cite{pmlr-v119-makkuva20a}.}
\label{fig:synth_ex}
\end{figure*}

\subsection{Evaluation on Synthetic Datasets.}\label{sec:EvalSynthetic}

We first evaluate the performance of \ourmethodFullCap\ against optimal transport methods returning primal couplings, namely Sinkhorn \cite{sinkhorn} (as implemented in \texttt{ott-jax} \cite{cuturi2022optimal}) and ProgOT \cite{kassraie2024progressive}. We evaluate the methods with respect to the Wasserstein-1 and Wasserstein-2 distance on an alignment of 1024 pairs of samples on the Checkerboard \cite{pmlr-v119-makkuva20a}, MAFMoons and Rings \cite{buzun2024expectile}, and Half-Moon and S-Curve \cite{buzun2024expectile} synthetic datasets (Fig.~\ref{fig:synth_ex}, Table~\ref{tab:cost_values_supp}). 

All methods are similarly effective at minimizing the primal OT cost <<FORMULA_0197>>, with small absolute difference in cost between the final couplings. \ourmethodFullCap\ achieves slightly lower primal cost on 4 out of the 6 evaluations. Notably, there is a massive difference in the number of non-zero entries (defined as entries <<FORMULA_0198>>) in the couplings output by \ourmethod{}, 
%coupling and the number of non-zero entries in the dense couplings of 
Sinkhorn, and ProgOT (Table~\ref{tab:entropy_nonzero_combined}). 
Specifically, across the experiments 
\ourmethod{} outputs a bijection with exactly 1024 non-zero elements in the coupling matrix, equal to the number of aligned samples.  In constrast,
Sinkhorn and ProgOT output couplings with 624733 to 678720 and 271087 to 337258 non-zero entries. 

%Moreover, the entropy of the \ourmethod\ coupling matrix is approximately half that of both Sinkhorn and ProgOT.


We evaluate the scalability of \ourmethodFullCap\ relative to other full-rank solvers on varying numbers of samples from the Half Moon \& S-Curve \cite{buzun2024expectile} synthetic dataset. We vary the rank from $2^{5} = 32$ ($64$ points aligned) up to $2^{20}$ = 1048576 points (2097152 points aligned) in $\mathbb{R}^{2}$, 
the latter dataset of a size that is beyond the capabilities of
%an order of magnitude 
%which is unprecedented for 
current optimal transport solvers. We observe that Sinkhorn \cite{sinkhorn} and ProgOT -- methods which produce dense mappings -- require  a coupling matrix with <<FORMULA_0199>> non-zero entries and thus run only up to 16384 points. 
\ourmethod{} yields solutions with 
%ProgOT and Sinkhorn %consistently yield solutions with 
comparable primal cost to ProgOT and Sinkhorn  on the sample sizes where all methods run. 

We also find that \ourmethod\ achieves an OT cost that is competitive with the dual revised simplex solver \cite{Huangfu2017}, a solver which only scales up to $512$ points (Table~\ref{tab:comparison_512}). This solver computes an \emph{optimal} coupling, unlike ProgOT and Sinkhorn which rely on entropic regularization. While we benchmark Sinkhorn in place of mini-batch OT on the synthetic datasets due to their limited complexity, we also evaluate the multi-scale method MOP on the 512 point instance (Table~\ref{tab:comparison_512}). Although MOP outputs a fast approximation to optimal transport, its primal cost on the Checkerboard \cite{pmlr-v119-makkuva20a} dataset is twice as high as that of the other methods, and it performs significantly worse on the MAF Moons \& Rings and Half Moon \& S-Curve datasets \cite{buzun2024expectile}.

Lastly, we observe that \ourmethodFullCap\ scales to over a million points, two orders of magnitude greater than ProgOT and Sinkhorn,  two full-rank OT methods that compute global alignments. We find \ourmethod\ scales linearly with the size of the problem instance (Fig.~\ref{fig:runtime_scaling}{a}) in contrast to the quadratic scaling in time complexity of Sinkhorn (Fig.~\ref{fig:runtime_scaling}{b}).


%In contrast, \ourmethodFullCap\ scales to over a million points, two orders of magnitude greater, while maintaining OT cost competitive with the dual revised simplex solver \cite{Huangfu2017}, which runs only up to $512$ points (Table~\ref{tab:comparison_512}). This solver outputs an \emph{optimal} plan, unlike ProgOT, Sinkhorn, and \ourmethod{} which rely on entropic regulatization. \ourmethod\ scales linearly with the problem instance -- albeit with a large constant --(Fig.~\ref{fig:runtime_scaling}{a}) in contrast to the quadratic scaling in time complexity of Sinkhorn (Fig.~\ref{fig:runtime_scaling}{b}).



\begin{comment}
\begin{figure}[!t]
% \vskip 0.2in
\centerline{\includegraphics[width=\linewidth]{images/synth_ex1.pdf}}
\caption{Comparison of the \ourmethodFullCap\ Mapping, the Sinkhorn Barycentric Map, and an optimal map computing using dual revised simplex for the \textbf{a.} Half-moon and S-curve dataset \cite{buzun2024expectile} of 4096 points (512 points for dual revised simplex) and \textbf{b.} Checkerboard dataset \cite{pmlr-v119-makkuva20a}.}
\label{fig:synth_ex}
\end{figure}
\end{comment}

\begin{comment}
\begin{figure}[!t]
\centerline{\includegraphics[width=\linewidth]{images/method_costs_samples_log.png}}
\caption{Primal OT cost for varying sample size on the synthetic half-moon S-curve dataset of \cite{buzun2024expectile} for \ourmethod, Sinkhorn, and ProgOT}
\label{fig:sample_complexity}
\end{figure}
\end{comment}

\subsection{Large-scale Matching Problems and Transcriptomics}




\begin{comment}
\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0200>> Across Embryonic Stages}
    \label{tab:cost_values_combined}
    \small % Reduce font size
    \begin{tabular}{l@{\hskip 4pt}ccc@{\hskip 4pt}cccc}
        \toprule 
        \textbf{Method} & \textbf{9.5-10.5} & \textbf{10.5-11.5} & \textbf{11.5-12.5} \\
        \midrule
        \ourmethod{}  & \textbf{21.81} & \textbf{14.81} & \textbf{16.14} \\
        Sinkhorn       & 21.91          & 14.89          & N/A            \\
        ProgOT         & 22.56          & 15.35          & N/A            \\
        FRLC (<<FORMULA_0201>>)  & 23.14          & 16.09          & 17.74          \\
        LOT (<<FORMULA_0202>>)   & 26.06          & 19.06          & 21.64          \\
        \midrule
        \textbf{Method} & \textbf{12-13.5} & \textbf{13-14.5} & \textbf{14-15.5} & \textbf{15-16.5} \\
        \midrule
        \ourmethod{}  & \textbf{14.57} & \textbf{13.78} & \textbf{14.29} \\
        Sinkhorn       & N/A            & N/A            & N/A            \\
        ProgOT         & N/A            & N/A            & N/A            \\
        FRLC (<<FORMULA_0203>>)  & 15.47          & 14.64          & 15.51          \\
        LOT (<<FORMULA_0204>>)   & -              & -              & -              \\
        \bottomrule
    \end{tabular}
\end{table}
\end{comment}

Recently, optimal transport has been applied to single-cell and spatial transcriptomics datasets to compute couplings between cells taken from different timepoints from developmental processes or perturbations  \cite{schiebinger2019optimal,lavenant2021towards, bunne2022proximal, Huizing2024, destot, klein2023moscot}.
%, demonstrating that optimal transport can be leveraged to learn the energy-landscape of biological processes. 
However, the size of current datasets \cite{chen2022spatiotemporal} ($>$100k cells) has exceeded the capacity of existing full-rank solvers, requiring low-rank approximations of the coupling \cite{scetbon2023unbalanced,klein2023moscot,HMOT} to produce alignments. 

We evaluate whether the full-rank solver of \ourmethodFullCap\ exhibits competitive alignments for such datasets. Specifically, we analyze the mouse organogenesis spatiotemporal transcriptomic atlas (MOSTA) datasets, which include spatial transcriptomics data from mouse embryos at successive 1-day time-intervals with increasing number $n$ of cells at each stage: E9.5 (<<FORMULA_0205>>), E10.5 (<<FORMULA_0206>>), E11.5 (<<FORMULA_0207>>), E12.5 (<<FORMULA_0208>>), E13.5 (<<FORMULA_0209>>), E14.5 (<<FORMULA_0210>>), E15.5 (<<FORMULA_0211>>), and E16.5 (<<FORMULA_0212>>).
%, where the embryonic mouse develops across the stages so that the sample-complexity $n$ increases with the numeric stage. 
For the cost we use the Euclidean distance <<FORMULA_0213>> in $60$-dimensional PCA space of expression vectors, so <<FORMULA_0214>>.



Sinkhorn and ProgOT are unable to produce alignments for the stages beyond E10.5 (<<FORMULA_0215>> cells), whereas \ourmethod, the low-rank solvers, and mini-batch OT (batch-sizes <<FORMULA_0216>> to <<FORMULA_0217>>) are able to continue scaling to $>10^{5}$ (Table~\ref{tab:cost_values_late}, Table~\ref{tab:cost_values_supp}). We observe that the Kantorovich cost of \ourmethod\ is consistently lower than all other methods for all timepoints (Table~\ref{tab:cost_values_late}, Table~\ref{tab:cost_values_supp}).

\ourmethod{} achieves a substantially lower cost than the low-rank solvers FRLC and LOT for rank <<FORMULA_0218>>, even though \ourmethod{} relies on low-rank optimal transport (FRLC) as a subroutine. This result underscores the empirical trend observed in Fig.~\ref{fig:samples}, where the refinement step of \ourmethod{} progressively decreases the primal cost of coarser low-rank couplings (Proposition~\ref{prop:one_step_bound_main}). While the mini-batch solvers exhibit competitive scaling up to the last pair, the primal cost of mini-batch is higher for all tested batch-sizes (Table~\ref{tab:cost_values_supp}). Unlike \ourmethod, mini-batch OT does not compute a global alignment and exhibits batch-size dependent error.


\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0219>> Across Later Embryonic Stages}
    \label{tab:cost_values_late}
    \small % Reduce font size
    \begin{tabular}{lcccc}
        \toprule
        \textbf{Method} & \textbf{E12-13.5} & \textbf{E13-14.5} & \textbf{E14-15.5} & \textbf{E15-16.5} \\
        \midrule
        \ourmethod{}        & \textbf{14.35} & \textbf{13.78} & \textbf{14.29} & \textbf{12.79} \\
        Sinkhorn        & -            & -            & -            & -           \\
        MB $128$ & 14.86
        & 14.14
        & 14.75 & 13.32 \\
        MB $1024$ & 14.45
        & 13.86
        & 14.43 & 12.91
        \\
        FRLC   & 15.47          & 14.64          & 15.51          & 14.00          \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{MERFISH Brain Atlas Alignment}

\begin{figure*}[tbp]
% \vskip 0.2in
\centerline{\includegraphics[width=.9\linewidth]{images/merfish_fig.pdf}}
\caption{
\textbf{a.}
\ourmethodFullCap{} alignment on MERFISH mouse brain data, using only spatial coordinates.
\textbf{b.} Abundance $\mathbf{v}^1$ of gene \emph{Slc17a7} in the source slice. \textbf{c.} Predicted \emph{Slc17a7} abundance <<FORMULA_0220>> from the source slice to the target slice, through the \ourmethod{} coupling.
\textbf{d.} Abundance $\mathbf{v}^2$ of the same gene in the target slice. 
Transferred abundances <<FORMULA_0221>> have cosine similarity $0.8098$ with true abundances $\mathbf{v}^2$ in the target.
}
\label{fig:merfish}
\end{figure*}


We ran \ourmethod{} on two slices of MERFISH Mouse Brain Receptor Map data from \href{https://info.vizgen.com/mouse-brain-map}{Vizgen} to test whether \ourmethod{} can produce biologically valid alignments using the \emph{only} spatial densities of each tissue. These spatial transcriptomics data consist of spatial and gene expression measurements at individual spots in three full coronal slices across three biological replicates. Our ``source'' dataset <<FORMULA_0222>> is replicate 3 of slice 2, while our ``target'' dataset <<FORMULA_0223>> is replicate 2 of slice 2, following the expression transfer task described \cite{clifton2023stalign} between these two slices. Each dataset has roughly 84k spots, where memory constraints prohibit instantiation a full-rank alignment as a matrix. Thus, solvers such as Sinkhorn \cite{sinkhorn} and ProgOT \cite{kassraie2024progressive} are unable to run on the dataset. 

We use only spatial information when building a map between the two slices, using the spatial Euclidean cost <<FORMULA_0224>>, after registering spatial coordinates <<FORMULA_0225>> and <<FORMULA_0226>> with an affine transformation. We gauged the quality of the \ourmethod{ }alignment (Fig.~\ref{fig:merfish}{a}), using gene expression abundances of five ``spatially-varying'' genes. Specifically, we observe that expression vector $\mathbf{v}^1$ of gene \emph{Slc17a7} in the source slice ( Fig.~\ref{fig:merfish}{b}) when transferred to target slice through the bijective mapping output by \ourmethod{}, denoted as <<FORMULA_0227>> (Fig.~\ref{fig:merfish}{c}), closely matches the observed expression vector $\mathbf{v}^2$ of \emph{Slc17a7} in the target slice
(Fig.~\ref{fig:merfish}{d}) with cosine similarity equal to $0.8098$.
%For gene \emph{Slc17a7}, the cosine similarity between $\mathbf{v}^2$ and $\hat{\mathbf{v}}$ is $0.8098$, 
For genes \emph{Slc17a7}, \emph{Grm4}, \emph{Olig1}, \emph{Gad1}, \emph{Peg10}, the corresponding cosine similarities between the transferred and observed expression vectors are $0.8098$, $0.7959$, $0.7526$, $0.4932$, $0.6015$, respectively.

For comparison, we also ran the low-rank methods FRLC \cite{FRLC} and LOT \cite{Scetbon2021LowRankSF} with and without subsampling, reporting their best scores, as discussed in Section~\ref{supp:exp_merfish}. For the gene \emph{Slc17a7}, FRLC's cosine similarity was $0.2373$, while LOT's cosine similarity was $0.3390$. For all five genes \emph{Slc17a7}, \emph{Grm4}, \emph{Olig1}, \emph{Gad1}, \emph{Peg10}, FRLC's scores were ($0.2373$, $0.2124$, $0.1929$, $0.0963$, $0.1550$, respectively, while LOT's scores were $0.3390$, $0.2712$, $0.3186$, $0.1666$, $0.1080$. 
%These scores are also listed  in Table~\ref{tab:merfish}; across 
Across all five genes \ourmethod{}'s scores were at least twice those of FRLC or LOT (Table~\ref{tab:merfish}) with gene abundances shown in Fig.~\ref{fig:merfish_supp}. On the same task, we compared against MOP, the method of \cite{gerber2017multiscale}, whose scores for the five genes were: ($0.5211$, $0.4714$, $0.5972$, 
$0.3571$, $0.2719$). Finally, we also benchmarked against mini-batch OT
using batch sizes ranging from 128 to 2048 in powers of two, whose best scores 
($0.7434$, 
$0.7822$,
$0.7056$,
$0.4912$,
$0.5683$)
were 
more comparable to that of the performance of \ourmethod{}. Across all methods and genes compared in 
Table~\ref{tab:merfish}, \ourmethod{} had greatest cosine similarity scores in the expression transfer task, while also having lowest transport cost.
Further experimental details are in Section~\ref{supp:exp_merfish}.



\subsection{ImageNet Alignment}
We demonstrate the scalability of \ourmethodFullCap{} on a large-scale and high-dimensional dataset by aligning $2048$-dimensional embeddings of $1.281$ million images from the ImageNet ILSVRC dataset \cite{deng2009imagenet, ILSVRC15}. 
Each image is embedded using using the ResNet50 architecture \cite{he2016deep}, and we construct two datasets, $\mathsf{X}$ and $\mathsf{Y}$, by taking a random 50:50 split of the embedded images. We align $\mathsf{X}$ and $\mathsf{Y}$ using \ourmethod, FRLC, and mini-batch OT with batch-sizes ranging from <<FORMULA_0228>> to <<FORMULA_0229>>. ProgOT, Sinkhorn, and LOT could not be run on the datasets due to memory constraints. \ourmethod\ yielded a primal OT cost of 18.974, while FRLC \cite{FRLC} solution had a primal OT cost of 24.119 for rank <<FORMULA_0230>> and mini-batch OT has costs of $21.89$ (<<FORMULA_0231>>) to $19.58$ (<<FORMULA_0232>>) (Table~\ref{tab:cost_values_imagenet_main}). 


\begin{comment}
\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0233>> for ImageNet \cite{deng2009imagenet, ILSVRC15} Alignment Task.}
    \label{tab:cost_values_imagenet_main}
    \small % Reduce font size

    \begin{tabular}{lcccccc}
        \toprule
        \textbf{Method} & \ourmethod\ & MB $128$ & MB $256$ & MB $512$ & MB $1024$ & FRLC \\
        \midrule
        \textbf{OT Cost} & \textbf{18.97} & 21.89 & 21.11 & 20.34 & 19.58 & 24.12 \\
        \bottomrule
    \end{tabular}
\end{table}
\end{comment}


\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0234>> for ImageNet \cite{deng2009imagenet, ILSVRC15} Alignment Task.}
    \label{tab:cost_values_imagenet_main}
    \scriptsize % Use smaller font size than \small
    \setlength{\tabcolsep}{4pt} % Reduce column separation
    \begin{tabular}{lcccccc}
        \toprule
        \textbf{Method} & \ourmethod\ & MB $128$ & MB $256$ & MB $512$ & MB $1024$ & FRLC \\
        \midrule
        \textbf{OT Cost} & \textbf{18.97} & 21.89 & 21.11 & 20.34 & 19.58 & 24.12 \\
        \bottomrule
    \end{tabular}
\end{table}


%We (1) computed the primal cost of the alignments, (2) visualized the alignments in the embedding space using t-SNE \cite{JMLR:v9:vandermaaten08a}, (3) plotted a number of images aligned under the \ourmethod\ mapping. 



\section{Discussion}


\ourmethodFullCap
computes the Monge map between large-scale datasets in linear space, but has several limitations. 
% Perhaps the most significant is the assumption that one is aligning datasets with 
First, we currently assume that the datasets 
$\mathsf{X}$ and $\mathsf{Y}$ have the same number of samples. 
%$|\mathsf{X}| = |\mathsf{Y}| = n$, 
%prohibiting immediate application to datasets of different sizes. 
In many machine learning applications, this is not a limiting factor, as 
one generally seeks to pair an equal number of source points $\mathbf{x}$ to target points $\mathbf{y}$. 
Second, while \ourmethodFullCap{} scales linearly in space and log-linearly in time, it still involves a constant dependent on the low-rank OT sub-procedure used -- this underscores the need to accelerate and stabilize low-rank OT solvers further \cite{scetbon2022lowrank, FRLC}. Finally, while \ourmethodFullCap  guarantees an optimal solution given an optimal black-box low-rank solver (Proposition~\ref{prop:low_rank_monge_main}), the low-rank solvers \cite{scetbon2022linear, FRLC} used in practice are not necessarily optimal, owing to the non-convexity of low-rank problems. 
%Finally, 
%curious limitations of \ourmethodFull\ is that since 
%the rank-schedule used in \ourmethodFullCap requires a  non-trivial factorization of $n$, and thus requires datasets that do not  have a prime number of samples. Of course, this limitation can be bypassed through light sub-sampling of one or both datasets, provided they are of comparable size. 

\begin{comment}
\ourmethodFullCap may be useful in neural OT approaches which learn 
a continuous Monge map between the densities of two datasets.
For example, \cite{seguy2018large} minimize a 
loss <<FORMULA_0235>> between a neural network $T_{\theta}$ with parameters $\theta$ and a Monge map $T$ over samples <<FORMULA_0236>>
(Remark~\ref{remark:Monge_regression}).
\ourmethodFullCap can generate datasets of Monge map pairs <<FORMULA_0237>> from unpaired samples  $(\mathbf{x}_{i})_{i=1}^{n}$ and $(\mathbf{y}_{i})_{i=1}^{n}$.
This suggests one may directly train a neural network $T_{\theta}$ to match these pairs, without the bias of mini-batching.
\end{comment}

Optimal transport has been successfully applied in deep learning frameworks, such as OT flow-matching \cite{tong2024improving}, computer vision and point cloud registration, \cite{yu2021cofinet, qin2022geometric}, among many others. The mini-batch procedure used to train many of these methods involves sampling two datasets <<FORMULA_0238>> and <<FORMULA_0239>> with batch-size $B$ and aligning them with Sinkhorn at every training iteration. \ourmethod\ suggests an alternative approach: one can precompute millions of \emph{globally aligned} pairs and then sample <<FORMULA_0240>> and the optimal mapping <<FORMULA_0241>> by indexing into these precomputed pairs. This approach applies to any loss function dependent on an OT alignment.

\ourmethodFullCap may also be useful in neural OT approaches which learn 
a continuous Monge map between the densities of two datasets.
For example, \cite{seguy2018large} minimize a 
loss <<FORMULA_0242>> between a neural network $T_{\theta}$ with parameters $\theta$ and a Monge map $T$ over samples <<FORMULA_0243>>
(Remark~\ref{remark:Monge_regression}). Thus, the procedure outlined above may be used to directly regress a neural network $T_{\theta}$ on the Monge map $T$ without the bias of mini-batching or entropy.


%\ourmethodFullCap can generate datasets of Monge map pairs $(\mathbf{x}_{i},T(\mathbf{x}_{i}))$ from unpaired samples  $(\mathbf{x}_{i})_{i=1}^{n}$ and $(\mathbf{y}_{i})_{i=1}^{n}$. This suggests one may directly train a neural network $T_{\theta}$ to match these pairs, without the bias of mini-batching.



%without solving a mini-batch OT problem for each training iteration.

%With properties such as input-convexity \cite{pmlr-v70-amos17b} used to approximate the Brenier potential $\varphi: \mathbb{R}^{d} \to \mathbb{R}$, one may also extrapolate the transport to new points $\mathbf{x}' \mapsto \nabla \varphi(\mathbf{x}')$.

%If $c(x,y) = \lVert x- y\rVert_{2}^{2}$ so that $\gamma$ is supported on the graph of the gradient of a convex function $\varphi$, one may also use input-convexity \cite{pmlr-v70-amos17b} to approximate the associated Brenier potential $\varphi: \mathbb{R}^{d} \to \mathbb{R}$ and extrapolate the transport to new points $\mathbf{x}' \mapsto \nabla \varphi(\mathbf{x}')$.


\section{Conclusion}

We introduce \ourmethodFullCap (\ourmethod), an algorithm to solve optimal transport with linear complexity in the number of points, making sparse, full-rank optimal transport feasible for large-scale datasets. Our algorithm leverages that low-rank optimal transport 
co-clusters points with their image under the  Monge map, refining bijections between partitions of each dataset across a hierarchy of scales, down to a bijective Monge map between the datasets at the finest scale. \ourmethodFullCap{} couplings achieve comparable primal cost to couplings obtained through full-rank entropic solvers, and scales to datasets with over a million points, % \ourmethodFullCap's ability to compute alignments between massive datasets will 
opening the door to applications previously infeasible for optimal transport.


\section*{Acknowledgements}  We thank Henri Schmidt for many helpful conversations. This research was supported by NIH/NCI grant U24CA248453 to B.J.R. J.G. is supported by the Schmidt DataX Fund at Princeton University made possible through a major gift from the Schmidt Futures Foundation. 

\section*{Impact Statement}


Optimal transport has emerged as a powerful tool in generative modeling, yet its widespread use has been limited by scalability constraints. \ourmethod{} overcomes this limitation by enabling the application of OT to datasets with millions of points. This advancement paves the way for integrating OT into large-scale deep generative models and modern vision and language tasks.

As with any computational tool which may advance large-scale generative modeling, there are potential issues with bias in training datasets and a possibility of misuse. Use of  \ourmethod{} in applications should be careful and transparent about these risks and utilize appropriate mitigation strategies.
%and transparent application of, particularly when applied in high-impact settings.


\section*{Code Availability}

Our implementation of \ourmethodFullCap\ is available at \href{https://github.com/raphael-group/HiRef}{https://github.com/raphael-group/HiRef}.

\begin{comment}
\section*{Impact Statement}

``This paper presents work whose goal is to advance the field of 
Machine Learning. There are many potential societal consequences 
of our work, none which we feel must be specifically highlighted here.''
\end{comment}

%\newpage

\bibliographystyle{icml2025}
\bibliography{bibliography}


% In the unusual situation where you want a paper to appear in the
% references without citing it in the main text, use \nocite
\nocite{langley00}

%\bibliography{example_paper}
%\bibliographystyle{icml2025}


\newpage
\appendix
\onecolumn

\begin{comment}
\textbf{Notes}
\begin{itemize}
    \item Who to compare against? (1) Sinkhorn, (2) ProgOT, (3) Neural OT (expectile, dual, and Monge Gap), (4) ??
    \item Which datasets to evaluate on? (1) Synthetic, (2) Connectome, (3) Transcriptomics, (4) ??
    \item Evaluate affect of levels of refinement on OT cost across rank (how does it decrease OT cost relative to low-rank)
    \item Can one show exact or approximate convergence using theoretical results from the convergence of LR OT?
    \item How does the approximation/how do properties of the algorithm depend on the rank-schedule? Can we say anything theoretical about a good choice for it?
    \item Can we show theoretically that at every step of refinement the cost decreases monotonically?
    \item Can we show precisely how the rank schedule will trade-off between time and space complexity?
\end{itemize}
\end{comment}

\begin{comment}
\begin{algorithm}[tb]
   \caption{Hierarchical Refinement}
   \label{alg:hr_ot}
\begin{algorithmic}
   \STATE {\bfseries Input:} Datasets <<FORMULA_0244>>, 
   %measures $\mu = \frac{1}{n} \sum_{i} \delta_{x_{i}}, \nu = \frac{1}{n} \sum_{i} \delta_{y_{i}}$, 
   \emph{balanced} low-rank OT solver <<FORMULA_0245>>, rank-schedule $(r_{t})_{t=1}^{\kappa}$ dividing $n$, and base-case rank <<FORMULA_0246>> [e.g., <<FORMULA_0247>>].
   \STATE <<FORMULA_0248>>
   \STATE \emph{{\color{gray}{\# Initialize coarsest co-clustering}}}
   \STATE <<FORMULA_0249>>, <<FORMULA_0250>>
   \STATE <<FORMULA_0251>>
   \WHILE{<<FORMULA_0252>>}
   \STATE <<FORMULA_0253>>
   \FOR{co-cluster tuples <<FORMULA_0254>>}
   \STATE \emph{{\color{gray}{\# Define empirical measures}}}
    \STATE <<FORMULA_0255>>
    \STATE <<FORMULA_0256>>
    \STATE \emph{{\color{gray}{\# Solve a balanced low-rank OT problem}}}
    \STATE <<FORMULA_0257>> \emph{{\color{gray}{\# Ensures even-splits}}}
    \STATE <<FORMULA_0258>>
    \STATE \emph{{\color{gray}{\# Refine sets into new co-clusters}}}
    \FOR{ <<FORMULA_0259>>}
    \STATE{ <<FORMULA_0260>>
    \STATE <<FORMULA_0261>>}
   \STATE  <<FORMULA_0262>>
   \ENDFOR{}
    \ENDFOR
    \STATE <<FORMULA_0263>>
   \ENDWHILE{}
   \STATE Return tuples <<FORMULA_0264>>
\end{algorithmic}
\end{algorithm}
\end{comment}


\setcounter{figure}{0} 
\setcounter{table}{0} 

\renewcommand{\thefigure}{S\arabic{figure}}
\renewcommand{\thetable}{S\arabic{table}}

\setcounter{equation}{0}
\renewcommand{\theequation}{S\arabic{equation}}

\newpage

\newpage

\section{Hierarchical-Refinement Algorithm}

\begin{algorithm}[htb]
\caption{Hierarchical Refinement for Full-Rank OT}
\label{alg:hr_ot_supp}
\begin{algorithmic}[1]
\Require 
  \textbf{Datasets} <<FORMULA_0265>>; 
  \textbf{Low-rank OT solver} <<FORMULA_0266>>;
  \textbf{Rank schedule} <<FORMULA_0267>>;
  \textbf{Base rank} <<FORMULA_0268>> (e.g. 1).
\Statex

\noindent \textbf{Initialize:}
\State <<FORMULA_0269>>, <<FORMULA_0270>>
\While{<<FORMULA_0271>> \textbf{ such that } \\
        <<FORMULA_0272>>}
    \State <<FORMULA_0273>>
    \For{<<FORMULA_0274>>}
        \If{ <<FORMULA_0275>> }
            \State <<FORMULA_0276>>
        \Else
            %\State Define empirical measures:
            \State <<FORMULA_0277>>
            \State <<FORMULA_0278>>
            \State <<FORMULA_0279>>
            \State <<FORMULA_0280>>
            \For{<<FORMULA_0281>>}
                \State <<FORMULA_0282>>
                \State <<FORMULA_0283>>
                \State <<FORMULA_0284>>
            \EndFor
            \State \Comment{\scriptsize<<FORMULA_0285>>\normalsize}
            \EndIf
    \EndFor
    \State <<FORMULA_0286>>
\EndWhile

\State \textbf{Output:} 
  <<FORMULA_0287>> 
  \quad \Comment{Set of refined pairs.}
\end{algorithmic}
\end{algorithm}

\section{Proofs}
\label{sec:supp_pfs}

Datasets $\mathsf{X}$ and $\mathsf{Y}$ are represented as discretely supported probability measures <<FORMULA_0288>> and <<FORMULA_0289>> for probability vectors <<FORMULA_0290>>, which we assume to be uniform: <<FORMULA_0291>>. We form the cost matrix $\mathbf{C}$ defined by 
<<FORMULA_0292>>
 In all cases below, we are concerned with the assignment problem \eqref{eq:monge_prob} for this cost matrix.

Let <<FORMULA_0293>> denote the set of (scaled) <<FORMULA_0294>> permutation matrices. By the Birkhoff-von Neumann theorem \cite{birkhoff1946tres}, an optimal solution to the <<FORMULA_0295>> assignment problem is attained at a permutation matrix in <<FORMULA_0296>>.

\begin{definition}
\label{def:monge_reg}
    Say that cost matrix <<FORMULA_0297>> is
    \emph{Monge rotated} if the identity matrix $\mb{I}$ is a solution to the assignment problem associated to $\mb{C}$, i.e.
    <<FORMULA_0298>>
\end{definition}
For arbitrary cost matrix <<FORMULA_0299>>, let <<FORMULA_0300>>,
and note that the column-permuted cost matrix 
<<FORMULA_0301>> is Monge rotated by construction. This is a consequence of the following identity, which holds for any permutation <<FORMULA_0302>>.
<<FORMULA_0303>>
Let <<FORMULA_0304>> denote the transport polytope between two uniform measures. For <<FORMULA_0305>>, say that a row of $\mb{Q}$ is \emph{soft} if at least two of its entries are positive, and call the row \emph{hard} otherwise. 
For rank <<FORMULA_0306>> such that $r$ divides $n$, 
let <<FORMULA_0307>> be the subset of <<FORMULA_0308>> consisting of transport plans $\mb{Q}$ with only hard rows. 
Below, we consider two low-rank OT problems associated to $\mb{C}^\dagger$. 
The first low-rank problem considered is 
<<FORMULA_0309>>
while the second low-rank problem considered is restricted to symmetric couplings:
<<FORMULA_0310>>
In either case, we have omitted the constant factor of $r$ coming from <<FORMULA_0311>>. 
We next introduce a technical condition on $\mb{C}$. Let <<FORMULA_0312>> be a cost matrix and let <<FORMULA_0313>> corresponding to permutation <<FORMULA_0314>>. Given partitions <<FORMULA_0315>> and 
<<FORMULA_0316>> of $[n]$ and <<FORMULA_0317>>, define the cost between two sets $I_a$, $J_b$ to be
<<FORMULA_0318>>
We call partition $\mathcal{I}$ \emph{balanced} if each block $I_a$ of $\mathcal{I}$ has the same number of elements, <<FORMULA_0319>>.

\begin{definition} 
\label{def:r_Monge_sep}
Cost matrix <<FORMULA_0320>> is 
\emph{$r$-Monge separable} if there exists a balanced partition <<FORMULA_0321>>, such that for any two permutations <<FORMULA_0322>>, one has
<<FORMULA_0323>>
We say that $\mb{C}$ is \emph{strictly $r$-Monge separable} if \eqref{eq:r_Monge_sep} holds with strict inequality $(<)$ for any <<FORMULA_0324>>. 
\end{definition}

One interesting feature of this definition is that while the sum is over <<FORMULA_0325>> terms, where it may occur that <<FORMULA_0326>>, this inequality must hold over all permutations $\pi_1$ and $\pi_2$ acting on the individual data points, rather than partition blocks. This captures the notion of finding low-rank or low-resolution solutions which are nevertheless compatible with the optimal bijective Monge map.

\begin{remark}
\label{rmk:r_Monge_sep}
    If $\mb{C}$ is $r$-Monge separable, the distinguished partition $\mathcal{I}^\star$ may be represented as <<FORMULA_0327>> such that $\mb{Q}^\star$ is optimal for \eqref{eq:lr_sym} and the pair
    <<FORMULA_0328>> is optimal for \eqref{prob:general_LROT}. After proving the next lemma, we will relate $r$-Monge separability to cyclic monotonicity. 
\end{remark}


\begin{proposition}\label{prop:low_rank_monge}
%[Monge Reduction Lemma]
Let <<FORMULA_0329>> be strictly $r$-Monge separable. If <<FORMULA_0330>> then, for all <<FORMULA_0331>>,
<<FORMULA_0332>>
where <<FORMULA_0333>> is the permutation corresponding to <<FORMULA_0334>>.
\end{proposition}
\begin{proof}
Let <<FORMULA_0335>> be as in the statement of the lemma, and define <<FORMULA_0336>>. The same reasoning as in \eqref{eq:monge_reg_id} implies that if <<FORMULA_0337>>, then
<<FORMULA_0338>>
The membership \eqref{eq:mcclem1} follows from the identities
<<FORMULA_0339>>
Remark~\ref{rmk:r_Monge_sep} above follows from the requirement that the variables <<FORMULA_0340>> have all hard rows, and are subject to uniform marginal constraints, so that all non-zero entries of <<FORMULA_0341>> have the same value. 
Thus, if 
$\mb{C}$ is $r$-Monge separable, there exists <<FORMULA_0342>> corresponding to distinguished balanced partition <<FORMULA_0343>> from Definition~\ref{def:r_Monge_sep} such that 
<<FORMULA_0344>>
Moreover, this pair <<FORMULA_0345>> is the unique optimum when $\mb{C}$ is strictly $r$-Monge separable. 
From \eqref{eq:mcclem1}, \eqref{eq:mcclem2}, we must have 
<<FORMULA_0346>>
from which \eqref{eq:monge_cc} follows immediately. 
\end{proof}

Let us now discuss how the notion of $r$-Monge separability is related to $c$-cyclic monotonicity. Recall that for a cost matrix <<FORMULA_0347>> derived from ground cost $c$ the support of an optimal plan is $c$-cyclically monotone if for all permutations <<FORMULA_0348>>, one has
<<FORMULA_0349>>
As it amounts to a reindexing of the sum on the right side of \eqref{eq:ccm} , one can equivalently define the support of the optimal plan to be $c$-cyclically monotone if for any \emph{pair} of permutations <<FORMULA_0350>>, 
<<FORMULA_0351>>
from which we see that $c$-cyclical monotonicity is equivalent to $r$-Monge separability with <<FORMULA_0352>>. 

We next show that the optimal factors <<FORMULA_0353>> for the rank-2 Wasserstein problem given in \eqref{eq:lora_wass} correspond to hard-partitions of each dataset, so that for this problem the optimal <<FORMULA_0354>> satisfy <<FORMULA_0355>>. Below, let <<FORMULA_0356>> be the indices on which column $i$ of $\mathbf{Q}^\star$ is supported, where <<FORMULA_0357>>. 
\begin{lemma}
\label{lem:supp_reduction_lemma}
    Let <<FORMULA_0358>> be optimal for the rank-2 Wasserstein problem \eqref{eq:lora_wass} subject to the additional constraint that <<FORMULA_0359>> and
    <<FORMULA_0360>> are uniform and <<FORMULA_0361>> is even. Then, <<FORMULA_0362>> is a partition of $[n]$, and symmetrically, so is <<FORMULA_0363>>, so <<FORMULA_0364>>.
\end{lemma}
\begin{proof} The cost is linear in <<FORMULA_0365>> respectively: the minimization in each variable given the other fixed can be expressed as
<<FORMULA_0366>>
Thus for any optimal $\mathbf{Q}^{\star}$ or $\mathbf{R}^{\star}$ fixed the minimization in the other variable is a linear optimal transport problem, where by Corollary 2.11 in \cite{Loera2013CombinatoricsAG} it holds that since the constraint matrix is totally unimodular with marginals integral (on rescaling), the optima $\mathbf{R}^{\star}$ and $\mathbf{Q}^{\star}$ must be vertices on the transport polytope $\Pi_{\bm{u}_{n}, \bm{u}_{2}}$ with integral entries (on rescaling, by $2n$ or $2m$). There are <<FORMULA_0367>> positive entries in any optimal rank <<FORMULA_0368>> solution \cite{Loera2013CombinatoricsAG, peyre2019computational}, so that $n$ (resp. $m$) being even and the rescaled rows and columns summing to $2$ and $n$ implies that there are exactly $n$ positive entries and thus that the vertices define partitions of $[n]$ and $[m]$. Thus, solutions to \ref{eq:supp_alternating} satisfy <<FORMULA_0369>>.
%Let us write optimal $(\mathbf{Q}^\star, \mathbf{R}^\star, \mathbf{g}^\star)$ for the $r=2$ problem \eqref{eq:lora_wass} as $(\mathbf{Q}, \mathbf{R}, \mathbf{g})$. Suppose for the sake of contradiction that $\mathbf{Q}$ does not correspond to a hard clustering. This means in particular there is $i \in [n]$ with $\mathbf{Q}_{i1} >0$ \emph{and} $\mathbf{Q}_{i2} > 0$. 
\end{proof}

Notably, in the case of an odd number of points $n$ or $m$ this likewise implies that one has a single row which has 2 entries <<FORMULA_0370>>, with all other rows of the form <<FORMULA_0371>> or <<FORMULA_0372>> defining a partition of the remaining even subset of size <<FORMULA_0373>> or <<FORMULA_0374>>. In the general case of ranks <<FORMULA_0375>> there are maximally <<FORMULA_0376>> \cite{peyre2019computational} non-zero edges (so that the graph is acyclic), and for <<FORMULA_0377>> the optimal solution remains close to a partition given mild assumptions on $\mathbf{C}$.

Lemma~\ref{lem:supp_reduction_lemma} states optimal low-rank couplings <<FORMULA_0378>> for Problem~\ref{eq:lora_wass_variant} over $\Pi_{(\bm{u}_{n},\bm{u}_{2})}$ are in $\Pi_{\bullet(\bm{u}_{n},\bm{u}_{2})}$. Thus, by Proposition~\ref{prop:low_rank_monge} these solutions co-cluster points <<FORMULA_0379>> with their image under Monge map <<FORMULA_0380>>, supposing the cost is strictly 2-Monge separable (Definition~\ref{def:r_Monge_sep}). This co-clustering is in the sense of the clustering functions <<FORMULA_0381>> from Proposition~\ref{prop:low_rank_monge_main} corresponding to each factor <<FORMULA_0382>>. We note that when $\mu$ and $\nu$ are discretely supported measures with supports of equal cardinality, a Monge map, <<FORMULA_0383>>, is guaranteed to exist by Theorem 2.7 of \cite{Thorpe2017IntroductionTO}.

\paragraph{On the Rank Schedule.} At each intermediate scale <<FORMULA_0384>>, the \emph{rank-schedule} <<FORMULA_0385>> determines the effective rank of the coupling computed so far. For each <<FORMULA_0386>>, define the \emph{effective rank} at scale $t$ as <<FORMULA_0387>>. This effective rank corresponds to the number of partitions, which are placed in bijective correspondence
<<FORMULA_0388>>
at the $t$-th step of \ourmethod{}. The size of the partitions at scale $t$ is given by <<FORMULA_0389>>. Given these preliminaries, we show that for an appropriate rank-schedule \ourmethodFullCap{} yields optimal transport maps. 

\begin{proposition}[Optimality of Hierarchical Refinement]
Suppose the Monge-map exists between two datasets $\mathsf{X}$, $\mathsf{Y}$ of size $n$. Then there exists a rank-schedule <<FORMULA_0390>> which factorizes $n$ such that all size <<FORMULA_0391>> partitions generated by Hierarchical Refinement at level $t$ satisfy strict $r_{t+1}$-Monge separability (Definition~\ref{def:r_Monge_sep}) for <<FORMULA_0392>>. For any such rank-schedule, given an optimal black-box low-rank solver over <<FORMULA_0393>>, Hierarchical Refinement returns the Monge-map.
%Refinement for $n = r^{\kappa}$ produces tuples $(x, T(x))$ corresponding to the optimal permutation assuming a black-box optimal low-rank solver.
\end{proposition}
\begin{proof}
For existence, observe that taking <<FORMULA_0394>> implies the statement <<FORMULA_0395>>. For partitions $I_{k}$ of size one, this is equivalent to the statement of $c$-cyclical monotonicity <<FORMULA_0396>>, so that for the trivial rank-schedule <<FORMULA_0397>> the cost is always $n$-Monge separable.

Given the existence of such a schedule <<FORMULA_0398>> with $r_{t+1}$-Monge separability, we proceed by induction on <<FORMULA_0399>>. For the base case of <<FORMULA_0400>>, as we assume the Monge map exists, for the initial partition <<FORMULA_0401>> one has that <<FORMULA_0402>>. We want to show the variant that $\Gamma_{t}$ contains sets which are co-clusters of sets with their image under $T$. As the inductive hypothesis, at scale <<FORMULA_0403>> with $\rho_{t}$ co-clusters <<FORMULA_0404>> each satisfies <<FORMULA_0405>>. As strict $r_{t+1}$-Monge separability holds for each size <<FORMULA_0406>> bipartition <<FORMULA_0407>>, using Proposition~\ref{prop:low_rank_monge} each such set is divided into $r_{t+1}$ co-clusters <<FORMULA_0408>> which satisfy <<FORMULA_0409>>. Thus, taking the union of these $r_{t+1}$ bi-partitions across the $\rho_{t}$ elements of $\Gamma_{t}$ we form a set $\Gamma_{t+1}$ of size <<FORMULA_0410>> which maintains the invariant that <<FORMULA_0411>>. At the final level $r_{\kappa}$ Monge separability holds, so one may conclude on singleton sets of the form <<FORMULA_0412>>.
%Proposition~\ref{prop:low_rank_monge} implies that each pair of sets co-clusters $\mathsf{X}^{(i)}$ with its image under the Monge-map as $T( \mathsf{X}^{(i)} ) = \mathsf{Y}^{(i)}$. Recursing on each set, as $r$-Monge separability holds, the sets at any level $t$ $(\mathsf{X}^{(t,j)}, \mathsf{Y}^{(t,j)})$ from $\Gamma_{t-1}$ maintain the invariant $T(\mathsf{X}^{(t,j)})= \mathsf{Y}^{(t,j)}$, so the inductive hypothesis holds at all levels up to singleton sets of the form $\Gamma_{\kappa} = (x, T(x))$.
\end{proof}
\begin{remark}\label{remark:base_rank}
Strict Monge separability applies unconditionally at the terminal level. Observe that all sets in $\Gamma_{\kappa - 1}$ have size equal to the rank <<FORMULA_0413>>, and that we have maintained the invariant that <<FORMULA_0414>>. Let <<FORMULA_0415>> denote the size $r_{\kappa}$ set of indices for $\mathsf{X}_{j}^{(\kappa-1)}$ in $\mathsf{X}$. By $c$-cyclical monotonicity, one has for all permutations <<FORMULA_0416>>
<<FORMULA_0417>>
Thus, for the subset of permutations on $n$ where <<FORMULA_0418>>, we have <<FORMULA_0419>> implying that one may solve a constant time <<FORMULA_0420>> solution to the assignment problem on each size $r_{\kappa}$ bipartition to recover the final map.
\end{remark}
We call $\rho_t$ the effective rank because (to avoid quadratic space complexity) we never instantiate the transport coupling corresponding to the bijective mapping \eqref{eq:supp_onetoone_t} as a matrix $\mathbf{T}^{(t)}$. Were we to instantiate $\mathbf{T}^{(t)}$, it would have rank $\rho_t$, and moreover we can evaluate its transport cost by using $\mathbf{T}^{(t)}$ to induce a transport coupling $\mathbf{P}^{(t)}$ between the full datasets <<FORMULA_0421>>.
<<FORMULA_0422>>
where <<FORMULA_0423>>, and where the mass <<FORMULA_0424>> is a simplified form of <<FORMULA_0425>>. We note that this is a rewriting of <<FORMULA_0426>> to have the indices ordered into a contiguous block-structure. Using coupling \eqref{eq:supp_P_corresp_t}, which again we never instantiate, one can define:
<<FORMULA_0427>>
The next proposition shows that the costs <<FORMULA_0428>> decrease as $t$ increases from $1$ to $\kappa$, and also provides a bound on their consecutive differences. Below, recall that each $\Gamma_t$ denotes the co-clustering <<FORMULA_0429>>, where
<<FORMULA_0430>> 
and where co-cluster $\Gamma_{t,q}$ is defined as:
<<FORMULA_0431>> 

\begin{proposition}[Proposition~\ref{prop:one_step_bound_main}]
\label{prop:one_step_bound}
%Suppose one has a strictly-convex and Lipschitz cost function $c(\cdot, \cdot)$, rank-schedule $(r_{1}, r_{2}, \cdots, r_{\kappa})$, sample size $n$, and step $t < \kappa$. Suppose one applies one step of Algorithm~\ref{alg:hr_ot} after hierarchy-depth $t$ to generate a refined coupling $\mathbf{P}^{(t+1)}$ from $\Gamma_{t}$ at depth $(t+1)$, and 
Let cost function <<FORMULA_0432>> be of the form <<FORMULA_0433>> for some strictly convex function <<FORMULA_0434>> and suppose that $h$ is Lipschitz. Let $\mathbf{P}^{(t)}$ be as defined above in \eqref{eq:supp_P_corresp_t}. Then one has the following bound on the difference in cost between iterations of refinement:
<<FORMULA_0435>>
where
<<FORMULA_0436>>
%where $q \in |\Gamma_{t}|$ indexes each refinement set $(X^{(t)}, Y^{(t)}) := (X_{q}^{(t)}, Y_{q}^{(t)}) \in \Gamma_{t}$.
\end{proposition}
    
\begin{proof}
By definition \eqref{eq:supp_P_corresp_t} of $\mathbf{P}^{(t)}$, 
<<FORMULA_0437>>
By Proposition~\ref{prop:low_rank_monge}, one then has:
%this reduces to the expected distortion of the set of points $X^{(t)}$ and $T(X^{(t)})$ under the current refined partition
<<FORMULA_0438>>
% if the cost $c(x_{i}, T(x_{j}))$ is not constant,
Note that the inner summands of \eqref{eq:full_term} (indexed by $q$) are non-negative by definition of the refinement step, where \emph{within} each cluster, one has a minimization 
over a larger set of couplings. 
%over a rank $r_{t+1}$ coupling with respect to the level $t$ cost $c( \mathsf{X}_{q}^{(t)},Y_{q}^{(t)} = T(X_{q}^{(t)}))$, and thus either maintaining or lowering the cost of coarse step $t$ coupling. 
This shows <<FORMULA_0439>>. 
\begin{comment}
<<FORMULA_0440>>
\end{comment}
Towards an upper bound, we will bound each summand of \eqref{eq:full_term}:
<<FORMULA_0441>>
Define <<FORMULA_0442>> as well as barycenters
<<FORMULA_0443>>
and note that by Jensen's inequality, for convex cost <<FORMULA_0444>> one has:
<<FORMULA_0445>>
so that we may continue upper-bounding the difference \eqref{eq:summand_ugly}:
<<FORMULA_0446>>
Now, define the diameter of co-cluster $\Gamma_{t,q}$ as follows:
<<FORMULA_0447>>
Using our Lipschitz assumption on $h$ made at the beginning of the section, where <<FORMULA_0448>> (we will write <<FORMULA_0449>> for <<FORMULA_0450>>), one has the inequality:
<<FORMULA_0451>>
Thus, returning to the bound on each summand \eqref{eq:summand_ugly}, we obtain the upper bound:
    <<FORMULA_0452>>
As partition $\mathsf{X}^{(t+1)}$ is a refinement of $\mathsf{X}^{(t)}$ and $\mathsf{Y}^{(t+1)}$ is a refinement of $\mathsf{Y}^{(t)}$, it holds that \eqref{eq:summand_ugly} is upper bounded by: 
<<FORMULA_0453>>
To conclude, we plug these bounds into each summand of \eqref{eq:full_term}, obtaining the following bound on the full sum:
<<FORMULA_0454>>
completing the proof. \end{proof}

\begin{remark} 
\label{rmk:conditional_ub}
Proposition~\ref{prop:one_step_bound} should be considered a \emph{conditional} result. Our proof follows that of (Proposition 1, \cite{gerber2017multiscale}), but they are able to provide sharper bounds between elements of a cluster and the centroid of the cluster using the properties assumed to hold in their definition of a multiscale family of partitions (Definition~\ref{def:reg_fam_msp}), which mimick the structure of dyadic cubes in Euclidean space. As we do not make any geometric assumptions of our partitions, the above result is a priori weaker, through we leave the exploration of the geometry of partitions induced by low-rank OT to future work.
\\
\end{remark}

\begin{remark}\label{remark:no_gain}
    Note, if <<FORMULA_0455>> is constant (i.e., if all points are equidistant in a block), one has that refinement offers no gain from level <<FORMULA_0456>>:
    <<FORMULA_0457>>
\end{remark}


\begin{remark}\label{remark:Monge_regression}
    The work \cite{seguy2018large} suggests a loss dependent on an (entropic) coupling $\gamma$. If $\gamma$ is  sparse and supported on the graph of the Monge map so that <<FORMULA_0458>>, this loss becomes a regression of a neural network $T_{\theta}$ on the Monge map $T$ over the support of $\mu$: <<FORMULA_0459>>.
\end{remark}
\begin{proof}
By linearity of the push-forward map one immediately obtains
<<FORMULA_0460>>
    By integrating against the $\delta$. As <<FORMULA_0461>>, it holds that this loss is identically zero if and only if <<FORMULA_0462>> on the dataset $(x_{i})_{i=1}^{n}$
    <<FORMULA_0463>>
\end{proof}
In other words, when one minimizes the objective of \cite{seguy2018large} using the bijective Monge map <<FORMULA_0464>> as opposed to an entropic coupling, the objective of \cite{seguy2018large} reduces to an unbiased regression. That is, the neural map $T_{\theta}$ directly matches $T$ over the dataset support as if trained on supervised <<FORMULA_0465>> pairs <<FORMULA_0466>>.

\section{Background: Multiscale Optimal Transport}

\subsection{Multiscale Partitions}

\cite{gerber2017multiscale} describe a general multiscale strategy for computing OT couplings between metric measure spaces <<FORMULA_0467>> and <<FORMULA_0468>>. They state this in the Kantorovich setting, using a general cost function <<FORMULA_0469>>. Their framework consists of several elements:
\begin{enumerate}
    \item A way of \emph{coarsening} the set of source points $\mathsf{X}$ and the measure $\mu$ across multiple scales:
    <<FORMULA_0470>>
    as well as an analogous coarsening for the set of target points $\mathsf{Y}$:
    <<FORMULA_0471>>
    where at each scale $j$, <<FORMULA_0472>> and <<FORMULA_0473>>, and the cardinality of each $\mathsf{X}_j$ and $\mathsf{Y}_j$ decreases with $j$. 
\item A way of \emph{propagating} coupling $\pi_j$ solving the transport problem <<FORMULA_0474>> at scale $j$ to a coupling $\pi_{j+1}$ at scale <<FORMULA_0475>>.
\item A way of \emph{refining the coupling} from scale $j$ to an optimal solution at scale <<FORMULA_0476>>. 
\end{enumerate}
To derive approximation bounds for the error incurred by the multiscale transport problem at each scale, \cite{gerber2017multiscale} use regular families of multiscale partitions (Definition~\ref{def:reg_fam_msp} below) to define approximations to <<FORMULA_0477>> and $\mathsf{c}$ at all scales. 

For <<FORMULA_0478>>, define <<FORMULA_0479>> as the metric ball of radius $r$ centered at $x$. Functions <<FORMULA_0480>> have the \emph{same order of magnitude} if there is <<FORMULA_0481>> with <<FORMULA_0482>> for all <<FORMULA_0483>>, and in this case we write <<FORMULA_0484>>. Write <<FORMULA_0485>> for the space of unsigned measures on $\mathsf{X}$, and write <<FORMULA_0486>> for the subspace of probability measures. 
\begin{definition}
    A metric space <<FORMULA_0487>> has \emph{doubling dimension} <<FORMULA_0488>> if every <<FORMULA_0489>> admits a covering by at most $2^d$ balls of radius <<FORMULA_0490>>.
\end{definition}
A metric space is said to be \emph{doubling} if it has doubling dimension $d$ for some <<FORMULA_0491>>. A related notion to a doubling metric space is a doubling measure.
\begin{definition}
    Measure <<FORMULA_0492>> is a \emph{doubling measure with dimension $d$} if there is a constant <<FORMULA_0493>> such that for all <<FORMULA_0494>> and all <<FORMULA_0495>>, one has <<FORMULA_0496>>, i.e. <<FORMULA_0497>>.
\end{definition}
Note that if <<FORMULA_0498>> is doubling, then $\mathsf{d}_{\mathsf{X}}$ is doubling, and up to modification of $d_{\mathsf{X}}$ to an equivalent metric, the dimension $d$ can be taken as the same in either case.

\begin{definition}
\label{def:reg_fam_msp}
Given metric measure space <<FORMULA_0499>>, a \emph{regular family of multiscale partitions} with scaling parameter <<FORMULA_0500>> is a family of sets 
<<FORMULA_0501>>
with each <<FORMULA_0502>> such that:
\begin{enumerate}
    \item For each scale $j$, the sets <<FORMULA_0503>> partition $\mathsf{X}$. 
    \item For each scale <<FORMULA_0504>>, either <<FORMULA_0505>> or <<FORMULA_0506>>. In this latter case, we say that <<FORMULA_0507>> is a \emph{child} of <<FORMULA_0508>>, or equivalently that <<FORMULA_0509>> is a \emph{parent} of <<FORMULA_0510>>, writing <<FORMULA_0511>>.
    \item There is a constant <<FORMULA_0512>> such that for all <<FORMULA_0513>>, we have diameter <<FORMULA_0514>>. 
    \item Each $C_{j,k}$ contains a ``center point'' $c_{j,k}$ such that <<FORMULA_0515>>.
\end{enumerate}
\end{definition}

We take <<FORMULA_0516>> for simplicity. As the child-parent terminology suggests, these partitions (through the second point) have a tree structure, like dyadic cubes in $\mathbb{R}^d$. Though the measure $\mu$ is not explicitly used in the above definition, the third and fourth points imply <<FORMULA_0517>> and <<FORMULA_0518>>.

\paragraph{Coarsening spaces and measures}

Now suppose that each of $\mathsf{X}$ and $\mathsf{Y}$ are each discrete metric measure spaces, each equipped with regular families <<FORMULA_0519>> of multiscale partitions:
<<FORMULA_0520>>
and these yield the coarsening chains in \eqref{eq:supp_X_chain}, \eqref{eq:supp_Y_chain} in the most natural way possible at each scale $j$, defining the coarse-grained spaces <<FORMULA_0521>> to be the clusters at scale $j$:
<<FORMULA_0522>>
while the measures at scale $j$ are defined from the measures at scale <<FORMULA_0523>> via:
<<FORMULA_0524>>
The fourth item of Definition~\ref{def:reg_fam_msp} requires that we define cluster centers <<FORMULA_0525>> for each <<FORMULA_0526>>.
At the finest scale <<FORMULA_0527>>, all clusters <<FORMULA_0528>> correspond to singletons <<FORMULA_0529>>, so we define <<FORMULA_0530>> in this case. At coarser scales, these centers can be defined recursively from the next finest scale, depending on the structure of $\mathsf{X}$. 

For example, if $\mathsf{X}$ has vector space structure (in addition to being a metric measure space), a natural choice for cluster centers $x_{j,k}$ at scale <<FORMULA_0531>> is the weighted average <<FORMULA_0532>>, where
<<FORMULA_0533>>
On the other hand, in the absence of vector space structure, one can still define 
<<FORMULA_0534>>
with analogous constructions for $\mathsf{Y}$ yielding centers $y_{j,k}$. 

\paragraph{Coarsening the cost function}

\cite{gerber2017multiscale} suggest three ways to coarsen the cost function using the multiscale partition. To condense the notation slightly, let us write $x_{j,k}$ in place of <<FORMULA_0535>> and $y_{j,k'} $ in place of <<FORMULA_0536>> and <<FORMULA_0537>>.
\begin{enumerate}
    \item[($\mathsf{c}$-i)] The pointwise value
    <<FORMULA_0538>>
    using centers $x_{j,k}$ and $y_{j,k'}$ defined in any of the ways above.
    \item[($\mathsf{c}$-ii)] The local average
    <<FORMULA_0539>>
    \item[($\mathsf{c}$-iii)] The local weighted average:
        <<FORMULA_0540>>
    where $\pi_{j-1}^\star$ is the optimal (or approximately optimal) OT coupling at scale <<FORMULA_0541>>, defined below. The indices $k_1$ and $k_1'$ are defined using the tree structure of the partition: $k_1$ is the unique index among <<FORMULA_0542>> such that <<FORMULA_0543>>, and likewise $k_1'$ is unique among <<FORMULA_0544>>.
\end{enumerate}

\subsection{Propagation of OT solutions across scales}

For each scale $j$, consider the OT problem given as follows. 
<<FORMULA_0545>>
\cite{gerber2017multiscale} show bounds on <<FORMULA_0546>> of a constant times <<FORMULA_0547>>, but note that this only implies closeness of the couplings in terms of their cost, not necessarily in any other sense.

Given an optimal coupling $\pi_j^\star$ at scale $j$, \cite{glimm2013iterative} proposed a direct propagation strategy to initialize the problem at scale <<FORMULA_0548>>, distributing the mass <<FORMULA_0549>> equally to all combinations of paths between <<FORMULA_0550>> and <<FORMULA_0551>>. In this context, a path is understood to mean a source-target pair at the next scale, e.g. a pair of the form <<FORMULA_0552>>. To formalize this, let 
<<FORMULA_0553>>
denote \emph{all} paths between points in $\mathsf{X}_j$ and $\mathsf{Y}_j$.
The drawback of this warm-start procedure is that if <<FORMULA_0554>>, which is always the case, the refinement procedure still requires quadratic space complexity at the finest scale. 

To mitigate the ultimate quadratic space complexity of retaining all possible paths at all scales, \cite{gerber2017multiscale} allow for a refinement procedure where the support of couplings at scale <<FORMULA_0555>> is restricted to a subset <<FORMULA_0556>> of all possible paths (with $\mathcal{R}_{j+1}$ defined by the optimal coupling at the previous iteration). Given <<FORMULA_0557>>, let $  \pi_j^\star |_{\mathcal{R}_j}$ denote the optimal solution to the path-restricted or \emph{restricted problem} at scale $j$:
<<FORMULA_0558>>

\paragraph{Simple propagation.}

The simplest way to restrict the number of paths considered at subsequent scales is to use paths at scale $j$ whose endpoints are children of mass-bearing paths at scale <<FORMULA_0559>>:
<<FORMULA_0560>>
The optimal Kantorovich plan at scale $j$ has at most <<FORMULA_0561>> non-zero entries. Using the above simple propagation strategy constrains plan at scale <<FORMULA_0562>> to be supported on at most
<<FORMULA_0563>>
entries, where $\alpha_j$ is the maximum number of children of any <<FORMULA_0564>> across both datasets. When the ambient space has doubling dimension $d$, for any $j$ one has <<FORMULA_0565>>, yielding a plan with \emph{linear} space complexity at the finest scale. 


\paragraph{Capacity constraint propagation.}

This propagation strategy solves a modified minimum flow problem at scale $j$ in order to include additional paths at scale <<FORMULA_0566>> likely to be included in the optimal solution $\pi_{j+1}^\star$. Concretely, one first computes an unconstrained optimal plan $\pi_j^\star|_{\mathcal{R}_j}$ at scale $j$. Then, a new OT plan <<FORMULA_0567>> is solved for at scale $j$ now subject to the capacity constraint
<<FORMULA_0568>>
for each <<FORMULA_0569>>, where the random variables $U_{k,k'}$ are i.i.d. $\mathrm{Uniform}([0.1, 0.9])$. This can also be iterated several times, in all cases leading to linear space complexity in the optimization at the finest scale. 

\subsection{Refinement of the propagated solution}

Propagation of a solution to the restricted transport problem \eqref{eq:supp_restricted_problem} at scale $j$, in general cannot guarantee reaching an optimal solution to the restricted problem at scale <<FORMULA_0570>>, and can lead to accumulation of errors across all scales. Several \emph{refinement} strategies are proposed in \cite{gerber2017multiscale} to address this.

\paragraph{Potential Refinement.}

One refinement strategy leverages the problem dual to \eqref{eq:kantorovich_problem}, here stated at the finest scale:
<<FORMULA_0571>>
The refinement strategy uses optimal dual variables <<FORMULA_0572>> to select paths to include at the next scale. From the dual formulation, an optimal solution <<FORMULA_0573>> to \eqref{eq:supp_kant_dual} must have all nonnegative entries in the \emph{reduced cost matrix}, defined as the matrix <<FORMULA_0574>> with entries
<<FORMULA_0575>>
Note that the dual to the restricted problem \eqref{eq:supp_restricted_problem} is well-defined, and for this dual we denote the optimal dual potentials by $\mathbf{f}^\star |_{\mathcal{R}_j}$ and $\mathbf{g}^\star |_{\mathcal{R}_j}$. With slight abuse of notation, let <<FORMULA_0576>> be
<<FORMULA_0577>>
where $\mathbf{M}^{(j)}$ is the indicator matrix of the restricted set of paths $\mathcal{R}_j$ at scale $j$, and where $\odot$ denotes the Hadamard (entrywise) product. While the restricted set of paths $\mathcal{R}_j$ is inherited from the previous scale, one can define a new set of paths $\mathcal{V}_j^0$ based on where the restricted reduced cost 
<<FORMULA_0578>>
is nonpositive:
<<FORMULA_0579>>
With a new set of paths <<FORMULA_0580>>, one can compute a new optimal plan $\pi_j^\star|_{\mathcal{Q}_j^0}$ at scale $j$ restricted to these paths, as well as \emph{new} optimal dual potentials $\mathbf{f}^\star |_{\mathcal{V}_j^0}$ and $\mathbf{g}^\star |_{\mathcal{V}_j^0}$ leading to a new reduced cost <<FORMULA_0581>>. This strategy can be iterated via
<<FORMULA_0582>>
yielding the sequence of transport plans $\pi_j^\star |_{\mathcal{Q}_j^i}$, all at scale $j$, 
which converge on a solution whose reduced cost is nonnegative, necessarily making it optimal. 
The potential refinement strategy was used by \cite{glimm2013iterative}, with \cite{schmitzer2016sparse} introducing shielding neighborhoods in a similar spirit, using dual potentials to locally verify global optimality. 

\begin{comment}
\paragraph{Neighborhood refinement}

A different refinement strategy, used in \cite{oberman2015efficient} uses the heuristic that ``simple propagation,'' defined above, yields sub-optimal...
\end{comment}


\section{Experimental Details}

\subsection{Synthetic Experiments}

For all of the synthetic experiments, we first generate <<FORMULA_0583>> points from three datasets: the checkerboard dataset (\cite{pmlr-v119-makkuva20a}), the MAFMoons and Rings dataset (\cite{buzun2024expectile}), and the Half-moon and S-curve dataset (\cite{buzun2024expectile}). Following \cite{buzun2024expectile} the random seed was set to $0$ for data-generation with \texttt{jax.random.key(0)}. We evaluate the OT cost <<FORMULA_0584>> of \ourmethod\, Sinkhorn \cite{sinkhorn}, and ProgOT \cite{kassraie2024progressive} on each of these three datasets, where we use (1) the Euclidean cost <<FORMULA_0585>>, and (2) the squared Euclidean cost <<FORMULA_0586>> (Table~\ref{tab:merged_comparison}). We additionally quantify the number of non-zero entries in the plan and its entropy (Table~\ref{tab:entropy_nonzero_combined}).

We also compare the cost of couplings computed by \ourmethodFullCap{} to low-rank couplings \cite{Scetbon2021LowRankSF,FRLC} of varying rank. We observe that as the latent rank <<FORMULA_0587>>, the OT cost <<FORMULA_0588>> asymptotically approaches the cost achieved by \ourmethodFullCap{} (Figure~\ref{fig:samples}). In the limit  <<FORMULA_0589>>  low-rank OT recovers Sinkhorn  \cite{scetbon2022lowrank} and approaches quadratic memory complexity, while \ourmethod\ remains linear in space.


\begin{table}[]
    \centering
    \caption{Hyperparameters for Synthetic Experiments}
    \label{tab:hyperparameters_full}
    \small % Optional: Reduce font size to fit content
    \begin{tabular}{@{}lll@{}}
        \toprule
        \textbf{Parameter Name}          & \textbf{Variable}         & \textbf{Value} \\ \midrule
        Rank-Annealing Schedule         & <<FORMULA_0590>> & [2, 512]        \\
        Hierarchy Depth                  & \( \kappa \)              & 2               \\
        Maximal Base Rank                & \( Q \)                   & \( 2^{10} \)     \\
        Maximal Intermediate Rank        & \( C \)                   & 16              \\ \bottomrule
    \end{tabular}
\end{table}

\textbf{Checkerboard}

The checkerboard dataset \cite{pmlr-v119-makkuva20a} is defined by random variables <<FORMULA_0591>> sampled from the source distribution according to <<FORMULA_0592>> where $\mathbf{X}$ and $\mathbf{Z}$ are sampled from Uniform distributions defined by
<<FORMULA_0593>>
the target distribution $P$ has random variable $\mathbf{Y}'$ where the random variable \( \mathbf{Y}' \) is defined as <<FORMULA_0594>> with components

<<FORMULA_0595>>


\textbf{MAFMoons and Rings}

The MAFMoon dataset \cite{buzun2024expectile} defines a source distribution $Q$ by sampling <<FORMULA_0596>> and applying the non-linear transformation defined by
<<FORMULA_0597>>
this introduces a quadratic dependency on the Gaussian randomly variable to generate a crescent shape.

The target distribution $P$ representing concentric rings is generated by first sampling <<FORMULA_0598>>, with fixed radii <<FORMULA_0599>> from which one transforms to Cartesian coordinates as <<FORMULA_0600>> and <<FORMULA_0601>>. Gaussian noise is added to each of these, as <<FORMULA_0602>> for <<FORMULA_0603>>.

\textbf{Half-moon and S-Curve}

The Half-moon and S-curve dataset \cite{buzun2024expectile} is generated from $\mathbf{Y}$ = \texttt{make\_moons} and \texttt{make\_S\_curve} from the \texttt{scikit-learn} library. Both datasets are transformed further with a rotation <<FORMULA_0604>>, a scaling $\lambda$, and a translation <<FORMULA_0605>> applied as <<FORMULA_0606>>.


\begin{table}[ht]
\centering
\caption{Comparison Table for Coupling-Based OT Methods on Primal Cost <<FORMULA_0607>> for <<FORMULA_0608>> and <<FORMULA_0609>>}
\label{tab:merged_comparison}
\small % Adjust font size
\begin{tabular}{lcccccc}
\toprule
\textbf{Method} & \multicolumn{2}{c}{\textbf{Checkerboard (Makkuva 2020)}} & \multicolumn{2}{c}{\textbf{MAFMoons \& Rings (Buzun 2024)}} & \multicolumn{2}{c}{\textbf{Half Moon \& S-Curve (Buzun 2024)}} \\
\cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-7}
& <<FORMULA_0610>> & <<FORMULA_0611>> & <<FORMULA_0612>> & <<FORMULA_0613>> & <<FORMULA_0614>> & <<FORMULA_0615>> \\
\midrule
Sinkhorn & 0.3573 & 0.1319 & 0.4422 & 0.4440 & \textbf{0.5663} & \textbf{0.5663} \\
ProgOT                     & N/A    & 0.1320 & N/A    & 0.4443 & N/A    & 0.5709 \\
\ourmethod                      & \textbf{0.3533} & \textbf{0.1248} & \textbf{0.4398} & \textbf{0.4414} & 0.5741 & 0.5737 \\
\bottomrule
\end{tabular}
\end{table}


\begin{table}[ht]
\centering
\caption{Entropy and Non-Zero Entries ( $> 10^{-8}$) of Coupling Matrices for Each Method and Dataset (Wasserstein-2 distance cost, <<FORMULA_0616>>)}
\label{tab:entropy_nonzero_combined}
\small % Adjust font size
\begin{tabular}{lccccccccc}
\toprule
\textbf{Method} & \multicolumn{2}{c}{\textbf{Checkerboard (Makkuva 2020)}} & \multicolumn{2}{c}{\textbf{MAFMoons \& Rings (Buzun 2024)}} & \multicolumn{2}{c}{\textbf{Half Moon \& S-Curve (Buzun 2024)}} \\
\cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-7}
& Entropy & Non-Zeros & Entropy & Non-Zeros & Entropy & Non-Zeros \\
\midrule
Sinkhorn  & 12.8509 & 624733 & 12.6117 & 678720 & 12.7776 & 652993 \\
ProgOT  & 12.3830 & 271087 & 11.6158 & 327764 & 12.1170 & 337258 \\
\ourmethod                      & \textbf{6.9314} & \textbf{1024}  & \textbf{6.9314} & \textbf{1024} & \textbf{6.9314} & \textbf{1024} \\
\bottomrule
\end{tabular}
\end{table}

\begin{comment}
\begin{table}[ht]
\centering
\caption{Comparison Table for Coupling-Based OT Methods on Primal Cost <<FORMULA_0617>> for <<FORMULA_0618>> on small 512 point instance}
\label{tab:comparison_512}
\small % Adjust font size
\begin{tabular}{lcccccc}
\toprule
\textbf{Method} & \multicolumn{2}{c}{\textbf{Checkerboard (Makkuva 2020)}} & \multicolumn{2}{c}{\textbf{MAFMoons \& Rings (Buzun 2024)}} & \multicolumn{2}{c}{\textbf{Half Moon \& S-Curve (Buzun 2024)}} \\
\cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-7}
& <<FORMULA_0619>> & <<FORMULA_0620>> & <<FORMULA_0621>> & <<FORMULA_0622>> & <<FORMULA_0623>> & <<FORMULA_0624>> \\
\midrule
Sinkhorn (\texttt{ott-jax}) & 0.3573 & 0.1319 & 0.4422 & 0.4440 & \textbf{0.5663} & \textbf{0.5663} \\
ProgOT                     & N/A    & 0.1320 & N/A    & 0.4443 & N/A    & 0.5709 \\
\ourmethod                      & \textbf{0.3533} & \textbf{0.1248} & \textbf{0.4398} & \textbf{0.4414} & 0.5741 & 0.5737 \\
\bottomrule
\end{tabular}
\end{table}
\end{comment}

\begin{table}[ht]
\centering
\caption{Comparison of Coupling-Based OT Methods on Primal Cost <<FORMULA_0625>> (Wasserstein-2) on 512 point small instance.}
\label{tab:comparison_512}
\small % Adjust font size
\renewcommand{\arraystretch}{0.9} % Adjust row spacing
\setlength{\tabcolsep}{5pt} % Adjust column spacing
\begin{tabular}{lccc}
\toprule
\textbf{Method} & \textbf{Checkerboard} & \textbf{MAF Moons \& Rings} & \textbf{Half Moon \& S-Curve} \\
\midrule
MOP \cite{gerber2017multiscale}
& 0.393
& 0.276
& 0.401
 \\
Sinkhorn (\texttt{ott-jax}) & 0.136 & 0.221 & 0.338 \\
ProgOT                      & 0.136 & 0.216 & 0.334 \\
\ourmethod                       & 0.129 & 0.216 & 0.334 \\
Dual Revised Simplex Solver & \textbf{0.127} & \textbf{0.214} & \textbf{0.332} \\
\bottomrule
\end{tabular}
\end{table}

\newpage

\subsection{Large-scale Transcriptomics Matching on Mouse-Embryo}

\begin{comment}
\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0626>> Across Early Embryonic Stages}
    \label{tab:cost_values_early}
    \small % Reduce font size
    \begin{tabular}{lccc}
        \toprule
        \textbf{Method} & \textbf{E9.5-10.5} & \textbf{E10.5-11.5} & \textbf{E11.5-12.5} \\
        \midrule
        \ourmethod{}        & \textbf{21.81} & \textbf{14.81} & \textbf{16.14} \\
        Sinkhorn        & 21.91          & 14.89          & -            \\
        ProgOT          & 22.56          & 15.35          & -            \\
        MB $128$ & 22.44
        & 15.35
        & 16.69 \\
        MB $256$ & 22.31
        & 15.18
        & 16.48
            \\
        FRLC (<<FORMULA_0627>>)  & 23.14          & 16.09          & 17.74          \\
        LOT (<<FORMULA_0628>>)  & 26.06          
        & 19.06 
        & 21.64       \\
        \bottomrule
    \end{tabular}
\end{table}
\end{comment}

\begin{table}[]
    \centering
    \caption{Hyperparameters for Mouse-Embryo Spatial Transcriptomics Experiment (E15.5-16.5)}
    \label{tab:hyperparameters_ME}
    \small % Optional: Reduce font size to fit content
    \begin{tabular}{@{}lll@{}}
        \toprule
        \textbf{Parameter Name}          & \textbf{Variable}         & \textbf{Value} \\ \midrule
        Rank-Annealing Schedule         & <<FORMULA_0629>> & [2, 86, 659]
        \\
        Hierarchy Depth                  & \( \kappa \)              & 3              \\
        Maximal Base Rank                & \( Q \)                   & \( 2^{10} \)     \\
        Maximal Intermediate Rank        & \( C \)                   & 128              \\ \bottomrule
    \end{tabular}
\end{table}

In this problem, we use \ourmethod\ to find a full-rank alignment matrix between successive pairs of spatial transcriptomics (ST) \cite{staahl2016visualization} slices. These are from a dataset of whole-mouse embryogenesis \cite{chen2022spatiotemporal} on the Stereo-Seq platform. These datasets have been measured at successive 1-day time-intervals: E9.5 (<<FORMULA_0630>>), E10.5 (<<FORMULA_0631>>), E11.5 (<<FORMULA_0632>>), E12.5 (<<FORMULA_0633>>), E13.5 (<<FORMULA_0634>>), E14.5 (<<FORMULA_0635>>), E15.5 (<<FORMULA_0636>>), and E16.5 (<<FORMULA_0637>>), where the embryonic mouse is growing across the stages so that the sample-complexity $n$ increases with the numeric stage. For each pair of datasets of size $n$ and $m$, we sub-sample the datasets so that the size of the two datasets is given as <<FORMULA_0638>>.

In the context of spatial transcriptomics, an experiment conducted on a two-dimensional tissue slice produces a data pair <<FORMULA_0639>>. Here, <<FORMULA_0640>> represents the gene expression matrix, where n denotes the number of cells (or spatial spots) analyzed on the slice, and p signifies the number of genes measured. Specifically, the entry <<FORMULA_0641>> corresponds to the expression level of gene j in cell i, with higher values indicating greater expression intensity. Concurrently, <<FORMULA_0642>> is the spatial coordinate matrix, where each row i contains the (x, y) coordinates of cell i on the tissue slice. Consequently, every cell on the slice is characterized by a gene expression vector of length p, capturing its molecular features, and a coordinate vector of length two, detailing its spatial position within the slice.

We utilize the extensive, real-world dataset on mouse embryo development presented in \cite{chen2022spatiotemporal}, which encompasses eight temporal snapshots of spatial transcriptomics (ST) slices throughout the entire mouse embryo development process. And align all consecutive timepoints. The preprocessing of this dataset is conducted using the standard SCANPY \cite{wolf2018scanpy} workflow. Initially, we ensure that both slices contain an identical set of genes by filtering, which results in a common gene set across all cells for each pair of timepoints. Subsequently, we apply log-normalization to the gene expression data of all cells from the two slices. To compress the data, we perform Principal Component Analysis (PCA), reducing the dimensionality of the gene expression profiles to <<FORMULA_0643>> PCs. Finally, we compute the Euclidean distances between gene expression vectors in the PCA-transformed space to construct the cost matrix $\mathbf{C}$, on which we solve a Wasserstein problem to obtain the optimal coupling $\mathbf{P}$ of full-rank. We offer hyperparameters for the E15-16.5 experiment (the largest alignment) in Table~\ref{tab:hyperparameters_ME}. For the other experiments, the maximal intermediate rank is <<FORMULA_0644>> up to E10.5, <<FORMULA_0645>> to E11.5, <<FORMULA_0646>> up to E13.5, and $128$ for E14.5-16.5. The rank-annealing schedule is generated according to the dynamic program in each case by the \texttt{rank\_annealing.optimal\_rank\_schedule( n, hierarchy\_depth , max\_Q , max\_rank )} function. 

In this experiment, we benchmark against the default implementation of Sinkhorn in \texttt{ott-jax} \cite{cuturi2022optimal} with entropy parameter <<FORMULA_0647>>, and additionally benchmark against the default implementations of \texttt{ProgOT} \cite{kassraie2024progressive} and \texttt{LOT} \cite{Scetbon2021LowRankSF} in \texttt{ott-jax}. For the low-rank methods \texttt{LOT} and \texttt{FRLC} \cite{FRLC} we fix a constant rank of <<FORMULA_0648>> for these experiments. While LOT \cite{Scetbon2021LowRankSF} provides a robust, scalable low-rank procedure for the Wasserstein-2 distance, the LOT solver with point cloud input on Wasserstein-1 cost only runs for the first pair (E9.5:E10.5). For subsequent pairs we input the cost $\mathbf{C}$ directly, resulting in the LOT solver running up to the third pair (E11.5:E12.5). Mini-batch OT is run with batch-sizes ranging from $128$ to $2048$, and is performed without replacement. As noted in prior works \cite{fatras2020learning, fatras2021jumbot, fatras2021minibatch}, this is a standard choice for instantiating a full-rank coupling using mini-batch OT. Sinkhorn is used to solve each mini-batch coupling, as implemented in \texttt{ott-jax} with a default setting of the entropy parameter <<FORMULA_0649>>.



\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0650>> for Different Methods Across Embryonic Stages}
    \label{tab:cost_values_supp}
    \begin{tabular}{lccccccc}
        \toprule
        \textbf{Method} & \textbf{E9.5-E10.5} & \textbf{E10.5-E11.5} & \textbf{E11.5-E12.5} & \textbf{E12.5-E13.5} & \textbf{E13.5-E14.5} & \textbf{E14.5-E15.5} & \textbf{E15.5-E16.5} \\
        \midrule
        \ourmethod{}  & \textbf{21.81} & \textbf{14.81} & \textbf{16.14} & \textbf{14.35} & \textbf{13.78} & \textbf{14.29} & \textbf{12.79} \\
        Sinkhorn  & 21.91 & 14.89 & -     & -    & -     & -     & -    \\
        ProgOT    & 22.56 & 15.35 & -    & -    & -     & -     & -   \\
        MB $128$ & 22.44 & 15.35 & 16.69 & 14.86 & 14.14 & 14.75 & 13.32
        \\
        MB $512$ & 22.15 &
                   15.05 &
                   16.33 &
                   14.54 &
                   13.92 &
                   14.50 &
                   13.01 \\
        MB $1024$ & 22.05 & 15.02 & 16.24 & 14.45 & 13.86 & 14.43 & 12.91 \\
        MB $2048$ & 21.98 &
                   14.98 &
                   16.18 &
                   14.39 &
                   13.81 &
                   14.39 &
                   12.85 \\
        FRLC     & 23.14 & 16.09 & 17.74 & 15.47 & 14.64 & 15.51 & 14.00 \\
        LOT & 26.06 & 19.06 & 21.64 & - & - & -
        \\
        \bottomrule
    \end{tabular}
\end{table}

% MB $256$ & 22.31 & 15.18 & 16.48 & 14.67 & 14.01 & 14.60 & 13.14 \\
\subsection{Brain Atlas Spatial Alignment}\label{supp:exp_merfish}

We took inspiration from MERFISH-MERFISH alignment experiments of \cite{clifton2023stalign}, particularly gene abundance transfer tasks that STalign is exhibited on. The data are available on the Vizgen website for MERFISH Mouse Brain Receptor Map data release (\href{https://info.vizgen.com/mouse-brain-map}{https://info.vizgen.com/mouse-brain-map}). The two spatial transcriptomics slices used for the experiment are slice 2, replicate 3 (``source'' dataset) and slice 2, replicate 2 (``target'' dataset). The datasets will be denoted <<FORMULA_0651>> for the source and <<FORMULA_0652>> for the target. 

The source dataset consists of $85,958$ spots, while the target dataset consists of $84,172$ spots. To apply \ourmethod{} to these data, we subsampled the source dataset to have $84,172$ spots also (uniformly at random), removing a total of $1786$ spots. We use this sub-sampled <<FORMULA_0653>> dataset for all methods, but as discussed below, note that this sub-sampling incurs little error. We ran \ourmethod{} using the settings \texttt{max\_rank = 11} and \texttt{hierarchy\_depth=4}, for a total runtime of 10 minutes 6 seconds, on an A100 GPU. The random seed was set to \texttt{44}.
For the cost function used by \ourmethod{}, we only use the \emph{spatial} modalities <<FORMULA_0654>> of the two datasets. We centered the spatial coordinates of both datasets, and applied a rotation by 45 degrees to the first dataset. With these registered spatial data, here denoted <<FORMULA_0655>> and <<FORMULA_0656>>, we formed the cost matrix $\mathbf{C}$ given by:
<<FORMULA_0657>>
where <<FORMULA_0658>> denotes the Euclidean distance between the spatial coordinates. This cost $\mathbf{C}$ was used as input to \ourmethod{}, which produced as output a 1-1 mapping $T$ between the two datasets (a permutation matrix is too large to instantiate). 

We then evaluated the performance of \ourmethod{} through cosine similarity of predicted gene abundance with target gene abundance, across five ``spatially-patterned genes''  (using the terminology of \cite{clifton2023stalign}): \emph{Slc17a7}, \emph{Grm4}, \emph{Olig1}, \emph{Gad1}, \emph{Peg10}. Writing $\mathfrak{g}$ to stand in for any of these genes, we formed the abundance vectors $\mathbf{v}^{1, \mathfrak{g}}$ and $\mathbf{v}^{2, \mathfrak{g}}$ using the raw counts for gene $\mathfrak{g}$ in each datasets' expression component <<FORMULA_0659>>. Using \ourmethod{} output $T$, we also formed the \emph{predicted} abundance vector <<FORMULA_0660>>, which maps the raw counts from $\mathbf{v}^{1, \mathfrak{g}}$ to the spots in the second dataset through $T$. 

Moreover, to compute cosine similarities between predicted and true expression abundances, \cite{clifton2023stalign} employ a spatial binning on their output, using windows of <<FORMULA_0661>> to tile each slice. The diameter of each slice is roughly <<FORMULA_0662>>, and 
to make our output comparable, we used the spatial coordinates $\mathbf{S}'$ to bin and average the vectors $\mathbf{v}^{2, \mathfrak{g}}$ and <<FORMULA_0663>> locally. We used a total of 5625 bins, corresponding to a 15-to-1 mapping from spots to bins. Averaging the abundance of gene $\mathfrak{g}$ in each bin, we obtain spatially smoothed versions of $\mathbf{v}^{2, \mathfrak{g}}$ and <<FORMULA_0664>>, as in \cite{clifton2023stalign}. Denote these smoothed vectors by $\mathbf{w}^{2, \mathfrak{g}}$ and <<FORMULA_0665>>. For each gene $\mathfrak{g}$ among $\{$ \emph{Slc17a7}, \emph{Grm4}, \emph{Olig1}, \emph{Gad1}, \emph{Peg10} $\}$, we computed the cosine similarity between $\mathbf{w}^{2, \mathfrak{g}}$ and <<FORMULA_0666>>, listing our results in Table~\ref{tab:merfish}. 
In the same table, we list scores obtained by the low-rank methods FRLC \cite{FRLC} and LOT \cite{Scetbon2021LowRankSF} for comparison. 
While \ourmethod{} is restricted to running on datasets of the same size, LOT and FRLC have no
such restriction, and can run on the 
pair of MERFISH slices without any subsampling.
To address this, in each case of LOT and FRLC, we give results
from the methods run on the datasets with \emph{and} without subsampling, reporting the highest scores for each method in main. In particular, we compared the cosine similarities for the original and sub-sampled dataset on a downstream task, as the primal OT cost is no longer directly comparable. Without the sub-sampling, the cosine score is only slightly higher than with: (0.3390, 0.2712, 0.3186, 0.1666, 0.1080) vs (0.3241, 0.2279, 0.3029, 0.1653, 0.0719). These scores remain significantly lower than those of hierarchical refinement on the sub-sampled data: (0.8098, 0.7959, 0.7526, 0.4932, 0.6015).

For the FRLC algorithm, we set <<FORMULA_0667>>, <<FORMULA_0668>>, <<FORMULA_0669>>, rank <<FORMULA_0670>>, using $20$ outer iterations and $300$ inner iterations. The runtime of FRLC was 1 minute 26 seconds on an A100 GPU. 
For the LOT algorithm, we were unable to pass a low-rank factorization of the distance matrix, so we had to use a smaller rank <<FORMULA_0671>> in order to avoid exceeding GPU memory (the choice <<FORMULA_0672>> led to memory usage of 30GB). We set <<FORMULA_0673>> and otherwise used the default settings of the method. The total runtime was 36 minutes 8 seconds on an A100 GPU. To form a spot-to-spot mapping from each transport plan output by FRLC and LOT, we mapped the spot with index $i$ in the first slice to the index argmax of the $i$-th row of the transport plan. Note that we ran LOT using the squared Euclidean cost as default, as passing
\texttt{cost\_fn=costs.Euclidean()} as an argument to \texttt{ott-jax}'s \texttt{PointCloud} raised an error. 
The discrepancy in transport cost between the two low rank methods reported in Table~\ref{tab:merfish} is explained by (i) needing to use squared-Euclidean cost in the case of LOT, and (ii) using a rank-$20$ plan of LOT versus the rank-$500$ plan of FRLC. 
We applied the exact same spatial averaging to the outputs of all methods. We plot the ground-truth and \ourmethod{}-predicted abundances in Figure~\ref{fig:merfish_supp}.

\begin{table}[t]
    \centering
    \caption{Cosine Similarity Scores for Expression Transfer \& Spatial Transport Cost}
    \label{tab:merfish}
    \begin{tabular}{lcccccccc}
        \toprule
        \textbf{Method} 
        & 
                \emph{Slc17a7}
        & 
        \emph{Grm4}
        & 
        \emph{Olig1}
        & 
        \emph{Gad1}
        & 
        \emph{Peg10}
        & Transport Cost \\
        \midrule
        \ourmethod{} (this work) & 
                \textbf{0.8098} & 
        \textbf{0.7959} & 
        \textbf{0.7526} & 
        \textbf{0.4932} & 
        \textbf{0.6015} &
        \textbf{330.3301}\\ %cost
        FRLC \cite{FRLC} & 
                {0.2180} & 
        {0.2124} & 
        {0.1929} & 
        {0.0963} & 
        {0.0991} & 
        {415.0683}\\
        FRLC, no subsampling &
        {0.2373} &
        {0.1896} &
        {0.1579} &
        {0.0644} &
        {0.1550} &
        {634.4158} \\ %cost
        LOT \cite{Scetbon2021LowRankSF} & 
                {0.3241} & 
        {0.2279} & 
        {0.3029} & 
        {0.1653} & 
        {0.0719} & 
        {3722.3171} \\ % cost
                LOT, no subsampling & 
                {0.3390} & 
        {0.2712} & 
        {0.3186} & 
        {0.1666} & 
        {0.1080} & 
        {3722.1360}\\
        MOP 
        \cite{gerber2017multiscale} &
        {0.5211} &
        {0.4714} &
        {0.5972} & 
        {0.3571} &
        {0.2719} & 
        {2479.6117} \\
        Mini-batch (128)
        & 
        {0.6693} & 
        {0.6637} & 
        {0.6442} & 
        {0.4150} &
        {0.4932} & 
        653.0491 \\ % cost
        Mini-batch (512)
        &
        {0.7089} &
        {0.7383} &
        {0.6771} &
        {0.4562} &
        {0.5383} & 
        438.1703 \\ % cost 
        Mini-batch (1,024) 
        & 
        {0.7256} & 
        {0.7621} &
        {0.6918} &
        {0.4733} &
        {0.5557} &
        384.2498 \\ % cost 
        Mini-batch (2,048) 
        &
        {0.7434} & 
        {0.7822} & 
        {0.7056} &
        {0.4912} & 
        {0.5683} & 
        349.2964 \\ % cost
        \bottomrule
    \end{tabular}
\end{table}


\subsection{Alignment of ImageNet Embeddings}\label{supp:imagenet_emb}

To demonstrate the scalability of \ourmethod{} to massive and high-dimensional datasets, we perform an alignment unprecedented for OT solvers: aligning $1.281$ million images from the ImageNet ILSVRC dataset \cite{ILSVRC15,deng2009imagenet}. A negligible amount of sub-sampling, $167$ points out of $1281167$, was applied so that $n$ divided into two integers <<FORMULA_0674>> of which neither is prime. From this, \texttt{rank\_annealing.optimal\_rank\_schedule( n, hierarchy\_depth , max\_Q , max\_rank )} was called to generate the depth 3 rank-annealing schedule of <<FORMULA_0675>> for \ourmethod{}. We used the ResNet50 architecture \cite{he2016deep} available at \href{https://download.pytorch.org/models/resnet50-0676ba61.pth}{https://download.pytorch.org/models/resnet50-0676ba61.pth} to generate embeddings of each image of dimension <<FORMULA_0676>>. We then took a 50:50 split of the dataset as the two image datasets <<FORMULA_0677>> to be aligned, where we used a random permutation of the indices of the dataset using \texttt{torch.randperm} so that the splits approximately represent the same distribution over images. We then aligned these image datasets using \ourmethod\, FRLC, and mini-batch OT. For <<FORMULA_0678>> we used the standard Euclidean cost defined by
<<FORMULA_0679>>
We use the sample-linear algorithm \cite{pmlr-v99-indyk19a} to factorize $\mathbf{C}$ into low-rank factors of dimensions <<FORMULA_0680>> paralleling the rank-schedule. The final cost values for each are shown in Table~\ref{tab:cost_values_imagenet_supp}.

\begin{table}[t]
    \centering
    \caption{Cost Values <<FORMULA_0681>> for ImageNet \cite{deng2009imagenet, ILSVRC15} Alignment Task.}
    \label{tab:cost_values_imagenet_supp}
    \small % Reduce font size
    \begin{tabular}{lccccccccc}
        \toprule
        \textbf{Method} & \ourmethod{} & Sinkhorn & MB $128$ & MB $256$ & MB $512$ & MB $1024$ & FRLC & LOT & ProgOT \\
        \midrule
        \textbf{OT Cost} & \textbf{18.97} & N/A & 21.89 & 21.11 & 20.34 & 19.58 & 24.12 & N/A & N/A \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[]
    \centering
    \caption{Hyperparameters for ImageNet Experiment}
    \label{tab:hyperparameters_imagenet}
    \small % Optional: Reduce font size to fit content
    \begin{tabular}{@{}lll@{}}
        \toprule
        \textbf{Parameter Name}          & \textbf{Variable}         & \textbf{Value} \\ \midrule
        Rank-Annealing Schedule         & <<FORMULA_0682>> & [7, 50, 1830]        \\
        Hierarchy Depth                  & \( \kappa \)              & 3               \\
        Maximal Base Rank                & \( Q \)                   & \( 2^{11} \)     \\
        Maximal Intermediate Rank        & \( C \)                   & 64              \\ \bottomrule
    \end{tabular}
\end{table}


\section{Additional Information}

There are a number of additional practical details regarding Algorithm~\ref{alg:hr_ot} in its actual implementation. In particular, to achieve linear scaling, one must also have sample-linear approximation of the distance matrix $\mathbf{C}$. We use the algorithm of \cite{pmlr-v99-indyk19a} to accomplish this, as discussed in Section~\ref{sec:low_rank_dist}. In addition, one requires parallel sequence of ranks for the distance matrices used at each step, <<FORMULA_0683>>. As a default, we set <<FORMULA_0684>> so that the ranks of the distance matrices parallel those of the coupling matrices. Moreover, \ourmethod{} has the capacity to be heavily parallelized: since Algorithm~\ref{alg:hr_ot} breaks each instance into independent partitions, one may also parallelize the low-rank sub-problems of Algorithm~\ref{alg:hr_ot} across compute nodes.

\subsection{Optimizing the Rank-Annealing Schedule}\label{sect:rank_schedule}

As discussed in Section~\ref{sec:rank_anneal}, the large constants required by low-rank OT (\textrm{LROT}) in practice encourage factorizations which have \emph{minimal} partial sums. In particular, one seeks a factorization which minimizes the number of times \textrm{LROT} is run as a sub-procedure. Suppose one defines the maximal admissible rank of the low-rank solutions to be <<FORMULA_0685>>, the hierarchy-depth to be $\kappa$, the number of data-points to be $n$, and the maximal-rank permissible for the base-case alignment to be $Q$. If <<FORMULA_0686>>, then one may take <<FORMULA_0687>>, <<FORMULA_0688>>, to observe that the total number of runs required is <<FORMULA_0689>>, where the ranks factor the sample-size as <<FORMULA_0690>>. Thus, to optimize the number of \textrm{LROT} calls for a given hierarchy-depth $\kappa$, one can optimize for the rank-annealing schedule by minimizing the sum of partial products defined by
<<FORMULA_0691>> subject to <<FORMULA_0692>>. Observing that this equals <<FORMULA_0693>> implies a standard dynamic-programming approach and store a table of factors up to $C$ to optimize this in <<FORMULA_0694>> time for <<FORMULA_0695>> generally pre-fixed constants. 

%The dynamic program accomplishing this is implemented in the \texttt{rank\_annealing} package by calling the \texttt{rank\_annealing.optimal\_rank\_schedule( n, hierarchy\_depth , max\_Q , max\_rank )} function. This depends on the number of data points $n$, the hierarchy depth $\kappa$, the maximal rank at the intermediate couplings $Q$, and the maximal rank to solve for the terminal coupling ($r_{base}$) \texttt{max\_rank}.

\paragraph{Low-rank distance matrix $\mathbf{C}$.}\label{sec:low_rank_dist} A key work \cite{pmlr-v99-indyk19a} showed that one may approximately factor a distance matrix $\mathbf{C}$ with linear complexity in the number of points $n$ (Algorithm~\ref{alg:dist_factorization}). For certain costs, e.g. squared Euclidean, this factorization can be given for free \cite{Scetbon2021LowRankSF}. We rely on both of these for low-rank factorizations of the distance matrix, so that both the space of the coupling and pairwise distance matrix scale linearly. 




\begin{algorithm}\label{alg:dist_factorization}
\caption{\quad Low-Rank approximation for distance matrix $\mathbf{C}$}
\begin{algorithmic}
\State Input point sets <<FORMULA_0696>>, <<FORMULA_0697>> in metric space $\mathcal{X}$ and metric $d$
\State Pick indices <<FORMULA_0698>> uniformly at random
\For{<<FORMULA_0699>> to $n$}
\State Update sample probability <<FORMULA_0700>>
\EndFor
\State Sample <<FORMULA_0701>> rows <<FORMULA_0702>>
\State Compute $\mathbf{U}$ using \cite{10.1145/1039488.1039494}
\State Compute $\mathbf{V}$ using \cite{chen2017condition}
\State return $\mathbf{V}$, $\mathbf{U}$
\end{algorithmic}
\end{algorithm}


\begin{figure}[tbp]
\begin{center}
\centerline{\includegraphics[width=.8\linewidth]{images/merfish_supp_fig.pdf}}
\caption{Abundance of 5 genes (\textbf{a.} \emph{Slc17a7}, \textbf{b.} \emph{Grm4}, \textbf{c.} \emph{Olig1}, \textbf{d.} \emph{Gad1}, \textbf{e.} \emph{Peg10}) in Allen Brain Atlas MERFISH dataset \cite{clifton2023stalign}. From left to right are plotted (1) abundance in the first dataset, (2) abundance in the second dataset, and (3) predicted abundance via transfer of the abundances in the first dataset under the mapping of \ourmethod.}
\label{fig:merfish_supp}
\end{center}
\end{figure}

\begin{figure*}[tbp]
% \vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=\linewidth]{images/HiRef_Runtime.pdf}}
\caption{Runtime scaling across sample-complexities $n$ of \textbf{a.} \ourmethodFullCap{} (\ourmethod{}) and \textbf{b.} Sinkhorn for Euclidean cost, <<FORMULA_0703>> (single CPU core). \ourmethodFullCap{} exhibits linear scaling for increasing $n$, whereas Sinkhorn exhibits quadratic scaling and is unable to run beyond 16k points. \textbf{c.} Runtime scaling of \ourmethod{} (GPU).}
\label{fig:runtime_scaling}
\end{center}
\end{figure*}

\begin{figure*}[tbp]
% \vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=0.5\linewidth]{images/Presentation7.pdf}}
\caption{\ourmethod\ cost and the cost of the low-rank OT solution of FRLC \cite{FRLC} across the coupling rank <<FORMULA_0704>>. }
\label{fig:samples}
\end{center}
\end{figure*}

\begin{figure*}[tbp]
% \vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=0.75\linewidth]{images/barycentric_comparison2.pdf}}
\caption{Comparison of optimal transport maps under (1) the \ourmethod\ alignment, and (2) the Sinkhorn \cite{sinkhorn} barycentric projection. \textbf{a.} The checkerboard dataset of \cite{pmlr-v119-makkuva20a}, \textbf{b.} the Half-moon and S-curve dataset of \cite{buzun2024expectile}, and \textbf{c.} the MAF-Moons Rings dataset of \cite{buzun2024expectile}.
}
\label{fig:synth_ex_supp}
\end{center}
\end{figure*}

\begin{figure*}[tbp]
% \vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=0.7\linewidth]{images/optimal_simplex.pdf}}
\caption{Alignments of the synthetic datasets of \cite{pmlr-v119-makkuva20a, buzun2024expectile} using the optimal dual revised simplex \cite{Huangfu2017} algorithm for small instances (512 points). \textbf{a.} The checkerboard dataset of \cite{pmlr-v119-makkuva20a}, \textbf{b.} the Half-moon and S-curve dataset of \cite{buzun2024expectile}, and \textbf{c.} the MAF-Moons Rings dataset of \cite{buzun2024expectile}.}
\label{fig:synth_ex_supp_2}
\end{center}
\end{figure*}




\end{document}

